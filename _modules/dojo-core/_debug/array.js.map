{"version":3,"file":"array.js","sourceRoot":"","sources":["array.ts"],"names":["toLength","toInteger","normalizeOffset","from","of","fill","findIndex","find","copyWithin"],"mappings":"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","sourcesContent":["import { MAX_SAFE_INTEGER as maxSafeInteger } from './number';\n\nexport interface ArrayLike<T> {\n\tlength: number;\n\t[n: number]: T;\n}\n\nexport interface MapCallback<T> {\n\t(element: T, index: number): T;\n}\n\nexport interface FindCallback<T> {\n\t(element: T, index: number, array: ArrayLike<T>): boolean;\n}\n\n/**\n * Ensures a non-negative, non-infinite, safe integer.\n * @param length The number to validate\n * @return A proper length\n */\nfunction toLength(length: number): number {\n\tlength = Number(length);\n\tif (isNaN(length)) {\n\t\treturn 0;\n\t}\n\tif (isFinite(length)) {\n\t\tlength = Math.floor(length);\n\t}\n\t// Ensure a non-negative, real, safe integer\n\treturn Math.min(Math.max(length, 0), maxSafeInteger);\n}\n\n/**\n * From ES6 7.1.4 ToInteger()\n * @param value A value to convert\n * @return An integer\n */\nfunction toInteger(value: any): number {\n\tvalue = Number(value);\n\tif (isNaN(value)) {\n\t\treturn 0;\n\t}\n\tif (value === 0 || !isFinite(value)) {\n\t\treturn value;\n\t}\n\n\treturn (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n}\n\n/**\n * Normalizes an offset against a given length, wrapping it if negative.\n * @param value The original offset\n * @param length The total length to normalize against\n * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n */\nfunction normalizeOffset(value: number, length: number): number {\n\treturn value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n}\n\nexport function from(arrayLike: string, mapFunction?: MapCallback<string>, thisArg?: {}): ArrayLike<string>;\nexport function from<T>(arrayLike: ArrayLike<T>, mapFunction?: MapCallback<T>, thisArg?: {}): ArrayLike<T>;\n/**\n * The Array.from() method creates a new Array instance from an array-like or iterable object.\n *\n * @param arrayLike An array-like or iterable object to convert to an array\n * @param [mapFunction] A map function to call on each element in the array\n * @param [thisArg] The execution context for the map function\n * @return The new Array\n */\nexport function from<T>(arrayLike: (string | ArrayLike<T>), mapFunction?: MapCallback<T>, thisArg?: {}): ArrayLike<T> {\n\tif (arrayLike == null) {\n\t\tthrow new TypeError('from: requires an array-like object');\n\t}\n\n\tif (mapFunction && thisArg) {\n\t\tmapFunction = mapFunction.bind(thisArg);\n\t}\n\n\tconst Constructor: any = this;\n\tconst items: ArrayLike<any> = Object(arrayLike);\n\tconst length: number = toLength(items.length);\n\t// Support extension\n\tconst array: any[] = (typeof Constructor === 'function') ? <any[]> Object(new Constructor(length)) : new Array(length);\n\n\tfor (let i = 0, value: any; i < length; i++) {\n\t\tvalue = items[i];\n\t\tarray[i] = mapFunction ? mapFunction(value, i) : value;\n\t}\n\n\tarray.length = length;\n\n\treturn array;\n}\n\nexport function of(...items: any[]): any[];\n/**\n * Creates a new array from the function parameters.\n *\n * @param arguments Any number of arguments for the array\n * @return An array from the given arguments\n */\nexport function of() {\n\treturn Array.prototype.slice.call(arguments);\n}\n\n/**\n * Fills elements of an array-like object with the specified value.\n *\n * @param target The target to fill\n * @param value The value to fill each element of the target with\n * @param [start] The first index to fill\n * @param [end] The (exclusive) index at which to stop filling\n * @return The filled target\n */\nexport function fill<T>(target: ArrayLike<T>, value: any, start?: number, end?: number): ArrayLike<T> {\n\tconst length = toLength(target.length);\n\tlet i = normalizeOffset(toInteger(start), length);\n\tend = normalizeOffset(end ? toInteger(end) : length, length);\n\n\twhile (i < end) {\n\t\ttarget[i++] = value;\n\t}\n\n\treturn target;\n}\n\n/**\n * Performs a linear search and returns the first index whose value satisfies the passed callback,\n * or -1 if no values satisfy it.\n *\n * @param target An array-like object\n * @param callback A function returning true if the current value satisfies its criteria\n * @param [thisArg] The execution context for the find function\n * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n */\nexport function findIndex<T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}): number {\n\tconst length = toLength(target.length);\n\n\tif (!callback) {\n\t\tthrow new TypeError('find: second argument must be a function');\n\t}\n\n\tif (thisArg) {\n\t\tcallback = callback.bind(thisArg);\n\t}\n\n\tfor (let i = 0; i < length; i++) {\n\t\tif (callback(target[i], i, target)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Finds and returns the first instance matching the callback or undefined if one is not found.\n *\n * @param target An array-like object\n * @param callback A function returning if the current value matches a criteria\n * @param [thisArg] The execution context for the find function\n * @return The first element matching the callback, or undefined if one does not exist\n */\nexport function find<T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}): T {\n\tconst index = findIndex<T>(target, callback, thisArg);\n\treturn index !== -1 ? target[index] : undefined;\n}\n\n/**\n * Copies data internally within an array or array-like object.\n *\n * @param target The target array-like object\n * @param offset The index to start copying values to; if negative, it counts backwards from length\n * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n * @return The target\n */\nexport function copyWithin<T>(target: ArrayLike<T>, offset: number, start?: number, end?: number): ArrayLike<T> {\n\tif (target == null) {\n\t\tthrow new TypeError('copyWithin: target must be an array-like object');\n\t}\n\n\tconst length = toLength(target.length);\n\toffset = normalizeOffset(toInteger(offset), length);\n\tstart = normalizeOffset(toInteger(start), length);\n\tend = normalizeOffset(end ? toInteger(end) : length, length);\n\tlet count = Math.min(end - start, length - offset);\n\n\tlet direction = 1;\n\tif (offset > start && offset < (start + count)) {\n\t\tdirection = -1;\n\t\tstart += count - 1;\n\t\toffset += count - 1;\n\t}\n\n\twhile (count > 0) {\n\t\tif (start in target) {\n\t\t\ttarget[offset] = target[start];\n\t\t}\n\t\telse {\n\t\t\tdelete target[offset];\n\t\t}\n\n\t\toffset += direction;\n\t\tstart += direction;\n\t\tcount--;\n\t}\n\n\treturn target;\n}\n"]}