{"version":3,"file":"ReadableStream.js","sourceRoot":"","sources":["ReadableStream.ts"],"names":["State","ReadableStream","ReadableStream.constructor","ReadableStream._allowPull","ReadableStream.desiredSize","ReadableStream.hasSource","ReadableStream.locked","ReadableStream.readable","ReadableStream.started","ReadableStream.queueSize","ReadableStream._cancel","ReadableStream._shouldApplyBackPressure","ReadableStream.cancel","ReadableStream.close","ReadableStream.enqueue","ReadableStream.error","ReadableStream.getReader","ReadableStream.pipeThrough","ReadableStream.pipeTo","ReadableStream.pipeTo.doPipe","ReadableStream.pipeTo.cancelSource","ReadableStream.pipeTo.closeDest","ReadableStream.pull","ReadableStream.requestClose","ReadableStream.tee"],"mappings":"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","sourcesContent":["import { Strategy } from './interfaces';\nimport Promise from '../Promise';\nimport ReadableStreamController from './ReadableStreamController';\nimport ReadableStreamReader from './ReadableStreamReader';\nimport SizeQueue from './SizeQueue';\nimport TransformStream from './TransformStream';\nimport * as util from './util';\nimport WritableStream, { State as WriteableState } from './WritableStream';\n\n/**\n * Options used when piping a readable stream to a writable stream.\n */\nexport interface PipeOptions {\n\t/**\n\t * Prevents the writable stream from erroring if the readable stream encounters an error.\n\t */\n\tpreventAbort?: boolean;\n\n\t/**\n\t *  Prevents the readable stream from erroring if the writable stream encounters an error.\n\t */\n\tpreventCancel?: boolean;\n\n\t/**\n\t * Prevents the writable stream from closing when the pipe operation completes.\n\t */\n\tpreventClose?: boolean;\n}\n\n/**\n * The Source interface defines the methods a module can implement to create a source for a {@link ReadableStream}.\n *\n * The Stream API provides a consistent stream API while {@link ReadableStream.Source} and {@link WritableStream.Sink}\n * implementations provide the logic to connect a stream to specific data sources & sinks.\n */\nexport interface Source<T> {\n\n\t/**\n\t * Tells the source to prepare for providing chunks to the stream.  While the source may enqueue chunks at this\n\t * point, it is not required.\n\t *\n\t * @param controller The source can use the controller to enqueue chunks, close the stream or report an error.\n\t * @returns A promise that resolves when the source's start operation has finished.  If the promise rejects,\n\t * \t\tthe stream will be errored.\n\t */\n\tstart?(controller: ReadableStreamController<T>): Promise<void>;\n\n\t/**\n\t * Requests that source enqueue chunks.  Use the controller to close the stream when no more chunks can\n\t * be provided.\n\t *\n\t * @param controller The source can use the controller to enqueue chunks, close the stream or report an error.\n\t * @returns A promise that resolves when the source's pull operation has finished.  If the promise rejects,\n\t * \t\tthe stream will be errored.\n\t */\n\tpull?(controller: ReadableStreamController<T>): Promise<void>;\n\n\t/**\n\t * Optional method implemented by seekable sources to set the seek position. Use the controller to report an error.\n\t * @param controller The source can use the controller to report an error.\n\t * @param position The position in the stream to seek to.\n\t * @returns A promise that resolves to the new seek position when the source's seek operation has finished.  If the\n\t *  \tpromise rejects, the stream will be errored.\n\t */\n\tseek?(controller: ReadableStreamController<T>, position: number): Promise<number>;\n\n\t/**\n\t * Indicates the stream is prematurely closing and allows the source to do any necessary clean up.\n\t *\n\t * @param reason The reason why the stream is closing.\n\t * @returns A promise that resolves when the source's pull operation has finished.  If the promise rejects,\n\t * \t\tthe stream will be errored.\n\t */\n\tcancel?(reason?: any): Promise<void>;\n}\n\n/**\n * `ReadableStream`'s possible states\n */\nexport enum State { Readable, Closed, Errored }\n\n/**\n * Implementation of a readable stream.\n */\nexport default class ReadableStream<T> {\n\n\t// ShouldReadableStreamPull\n\tprotected get _allowPull(): boolean {\n\t\treturn !this.pullScheduled &&\n\t\t\t!this.closeRequested &&\n\t\t\tthis._started &&\n\t\t\tthis.state !== State.Closed &&\n\t\t\tthis.state !== State.Errored &&\n\t\t\t!this._shouldApplyBackPressure();\n\t}\n\n\t/**\n\t * Returns a number indicating how much additional data can be pushed by the source to the stream's queue before it\n\t * exceeds its `highWaterMark`. An underlying source should use this information to determine when and how to apply\n\t * backpressure.\n\t *\n\t * @returns The stream's strategy's `highWaterMark` value minus the queue size\n\t */\n\t// 3.5.7. GetReadableStreamDesiredSize ( stream )\n\tget desiredSize(): number {\n\t\treturn this._strategy.highWaterMark - this.queueSize;\n\t}\n\n\tget hasSource(): boolean {\n\t\treturn this._underlyingSource != null;\n\t}\n\n\t/**\n\t * A stream can only have one reader at a time. This value indicates if a stream already has a reader, and hence\n\t * cannot be read from other than by that reader. When a consumer is done with a reader they can dissociate it\n\t * by calling {@link ReadableStreamReader#releaseLock}.\n\t *\n\t * @returns True if the stream has a reader associated with it\n\t */\n\t// IsReadableStreamLocked\n\tget locked(): boolean {\n\t\treturn this.hasSource && !!this.reader;\n\t}\n\n\tget readable(): boolean {\n\t\treturn this.hasSource && this.state === State.Readable;\n\t}\n\n\t/**\n\t * This promise will resolve when the stream's underlying source has started and is ready to provide data. If\n\t * the {@link ReadableStreamReader#read} method is called before the stream has started it will not do anything.\n\t * Wait for this promise to resolve to ensure that your `read` calls are responded to as promptly as possible.\n\t *\n\t * @returns A promise that resolves when the stream is ready to be read from.\n\t */\n\tget started(): Promise<void> {\n\t\treturn this._startedPromise;\n\t}\n\n\tget queueSize(): number {\n\t\treturn this.queue.totalSize;\n\t}\n\n\tprotected _pullingPromise: Promise<void>;\n\tprotected _started: boolean;\n\tprotected _startedPromise: Promise<void>;\n\tprotected _strategy: Strategy<T>;\n\tprotected _underlyingSource: Source<T>;\n\n\tcloseRequested: boolean = false;\n\tcontroller: ReadableStreamController<T>;\n\tpullScheduled: boolean;\n\tqueue: SizeQueue<T>;\n\treader: ReadableStreamReader<T>;\n\tstate: State;\n\tstoredError: Error;\n\n\t/**\n\t * A `ReadableStream` requires an underlying source to supply data. The source interacts with the stream through\n\t * a {@link ReadableStreamController} that is associated with the stream, and provided to the source.\n\t *\n\t * @constructor\n\t * @param underlyingSource The source object that supplies data to the stream by interacting with its controller.\n\t * @param strategy The strategy for this stream.\n\t */\n\tconstructor(underlyingSource: Source<T>, strategy: Strategy<T> = {}) {\n\t\tif (!underlyingSource) {\n\t\t\tthrow new Error('An ReadableStream Source must be provided.');\n\t\t}\n\t\tthis.state = State.Readable;\n\t\tthis._underlyingSource = underlyingSource;\n\t\tthis.controller = new ReadableStreamController(this);\n\t\tthis._strategy = util.normalizeStrategy(strategy);\n\t\tthis.queue = new SizeQueue<T>();\n\t\tthis._startedPromise = new Promise<void>((resolveStarted) => {\n\t\t\tconst startResult = util.invokeOrNoop(this._underlyingSource, 'start', [ this.controller ]);\n\t\t\tPromise.resolve(startResult).then(() => {\n\t\t\t\tthis._started = true;\n\t\t\t\tresolveStarted();\n\t\t\t\tthis.pull();\n\t\t\t}, (error: Error) => {\n\t\t\t\tthis.error(error);\n\t\t\t});\n\t\t});\n\t}\n\n\tprotected _cancel(reason?: any): Promise<void> {\n\t\t// 3.2.4.1-3: return cancelReadableStream(this, reason);\n\t\tif (this.state === State.Closed) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tif (this.state === State.Errored) {\n\t\t\treturn Promise.reject(new TypeError('3.5.3-2: State is errored'));\n\t\t}\n\n\t\tthis.queue.empty();\n\t\tthis.close();\n\t\treturn util.promiseInvokeOrNoop(this._underlyingSource, 'cancel', [ reason ]).then(function () {});\n\t}\n\n\t// shouldReadableStreamApplyBackPressure\n\tprotected _shouldApplyBackPressure(): boolean {\n\t\tconst queueSize = this.queue.totalSize;\n\n\t\treturn queueSize > this._strategy.highWaterMark;\n\t}\n\n\t/**\n\t *\n\t * @param reason A description of the reason the stream is being canceled.\n\t * @returns A promise that resolves when the stream has closed and the call to the underlying source's `cancel`\n\t * method has completed.\n\t */\n\tcancel(reason?: any): Promise<void> {\n\t\tif (!this.hasSource) {\n\t\t\treturn Promise.reject(new TypeError('3.2.4.1-1: Must be a ReadableStream'));\n\t\t}\n\n\t\treturn this._cancel(reason);\n\t}\n\n\t/**\n\t * Closes the stream without regard to the status of the queue.  Use {@link requestClose} to close the\n\t * stream and allow the queue to flush.\n\t *\n\t */\n\t// 3.5.4. FinishClosingReadableStream ( stream )\n\tclose(): void {\n\t\tif (this.state !== State.Readable) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state = State.Closed;\n\n\t\tif (this.locked) {\n\t\t\tthis.reader.release();\n\t\t}\n\t}\n\n\t// EnqueueInReadableStream\n\tenqueue(chunk: T): void {\n\t\tconst size = this._strategy.size;\n\n\t\tif (!this.readable || this.closeRequested) {\n\t\t\tthrow new Error('3.5.6-1,2: Stream._state should be Readable and stream.closeRequested should be true');\n\t\t}\n\n\t\tif (!this.locked || !this.reader.resolveReadRequest(chunk)) {\n\n\t\t\ttry {\n\t\t\t\tlet chunkSize = 1;\n\t\t\t\tif (size) {\n\t\t\t\t\tchunkSize = size(chunk);\n\t\t\t\t}\n\t\t\t\tthis.queue.enqueue(chunk, chunkSize);\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tthis.error(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tthis.pull();\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state !== State.Readable) {\n\t\t\tthrow new Error('3.5.7-1: State must be Readable');\n\t\t}\n\n\t\tthis.queue.empty();\n\t\tthis.storedError = error;\n\t\tthis.state = State.Errored;\n\n\t\tif (this.locked) {\n\t\t\tthis.reader.release();\n\t\t}\n\t}\n\n\t/**\n\t * create a new {@link ReadableStreamReader} and lock the stream to the new reader\n\t */\n\t// AcquireReadableStreamReader\n\tgetReader(): ReadableStreamReader<T> {\n\t\tif (!this.readable) {\n\t\t\tthrow new TypeError('3.2.4.2-1: must be a ReadableStream instance');\n\t\t}\n\n\t\treturn new ReadableStreamReader(this);\n\t}\n\n\tpipeThrough(transformStream: TransformStream<T, any>, options?: PipeOptions): ReadableStream<T> {\n\t\tthis.pipeTo(transformStream.writable, options);\n\t\treturn transformStream.readable;\n\t}\n\n\tpipeTo(dest: WritableStream<T>, options: PipeOptions = {}): Promise<void> {\n\t\tlet resolvePipeToPromise: () => void;\n\t\tlet rejectPipeToPromise: (error: Error) => void;\n\t\tlet closedPurposefully = false;\n\t\tlet lastRead: any;\n\t\tlet reader: ReadableStreamReader<T>;\n\n\t\tfunction doPipe(): void {\n\t\t\tlastRead = reader.read();\n\t\t\tPromise.all([ lastRead, dest.ready ]).then(function ([ readResult ]) {\n\t\t\t\tif (readResult.done) {\n\t\t\t\t\tcloseDest();\n\t\t\t\t}\n\t\t\t\telse if (dest.state === WriteableState.Writable ) {\n\t\t\t\t\tdest.write(readResult.value);\n\t\t\t\t\tdoPipe();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction cancelSource(reason: any): void {\n\t\t\tif (!options.preventCancel) {\n\t\t\t\treader.cancel(reason);\n\t\t\t\trejectPipeToPromise(reason);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlastRead.then(function () {\n\t\t\t\t\treader.releaseLock();\n\t\t\t\t\trejectPipeToPromise(reason);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction closeDest(): void {\n\t\t\tconst destState = dest.state;\n\t\t\tif (!options.preventClose &&\n\t\t\t\t(destState === WriteableState.Waiting || destState === WriteableState.Writable)) {\n\n\t\t\t\tclosedPurposefully = true;\n\t\t\t\tdest.close().then(resolvePipeToPromise, rejectPipeToPromise);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolvePipeToPromise();\n\t\t\t}\n\t\t}\n\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tresolvePipeToPromise = resolve;\n\t\t\trejectPipeToPromise = reject;\n\n\t\t\treader = this.getReader();\n\t\t\treader.closed.catch((reason: any) => {\n\t\t\t\t// abortDest\n\t\t\t\tif (!options.preventAbort) {\n\t\t\t\t\tdest.abort(reason);\n\t\t\t\t}\n\t\t\t\trejectPipeToPromise(reason);\n\t\t\t});\n\n\t\t\tdest.closed.then(\n\t\t\t\tfunction () {\n\t\t\t\t\tif (!closedPurposefully) {\n\t\t\t\t\t\tcancelSource(new TypeError('destination is closing or closed and cannot be piped to anymore'));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcancelSource\n\t\t\t);\n\t\t\tdoPipe();\n\t\t});\n\t}\n\n\t// RequestReadableStreamPull\n\tpull(): void {\n\t\tif (!this._allowPull) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._pullingPromise) {\n\t\t\tthis.pullScheduled = true;\n\t\t\tthis._pullingPromise.then(() => {\n\t\t\t\tthis.pullScheduled = false;\n\t\t\t\tthis.pull();\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis._pullingPromise = util.promiseInvokeOrNoop(this._underlyingSource, 'pull', [ this.controller ]);\n\t\tthis._pullingPromise.then(() => {\n\t\t\tthis._pullingPromise = undefined;\n\t\t}, (error: Error) => {\n\t\t\tthis.error(error);\n\t\t});\n\t}\n\n\t/**\n\t * Requests the stream be closed.  This method allows the queue to be emptied before the stream closes.\n\t *\n\t */\n\t// 3.5.3. CloseReadableStream ( stream )\n\trequestClose(): void {\n\t\tif (this.closeRequested || this.state !== State.Readable) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.closeRequested = true;\n\n\t\tif (this.queue.length === 0) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/**\n\t * Tee a readable stream, returning a two-element array containing\n\t * the two resulting ReadableStream instances\n\t */\n\t// TeeReadableStream\n\ttee(): [ ReadableStream<T>, ReadableStream<T> ] {\n\t\tif (!this.readable) {\n\t\t\tthrow new TypeError('3.2.4.5-1: must be a ReadableSream');\n\t\t}\n\n\t\tlet branch1: ReadableStream<T>;\n\t\tlet branch2: ReadableStream<T>;\n\n\t\tconst reader = this.getReader();\n\t\tconst teeState: any = {\n\t\t\tclosedOrErrored: false,\n\t\t\tcanceled1: false,\n\t\t\tcanceled2: false,\n\t\t\treason1: undefined,\n\t\t\treason2: undefined\n\t\t};\n\t\tteeState.promise = new Promise(function (resolve) {\n\t\t\tteeState._resolve = resolve;\n\t\t});\n\n\t\tconst createCancelFunction = (branch: number) => {\n\t\t\treturn (reason?: any): Promise<void> => {\n\t\t\t\tteeState['canceled' + branch] = true;\n\t\t\t\tteeState['reason' + branch] = reason;\n\t\t\t\tif (teeState['canceled' + (branch === 1 ? 2 : 1)]) {\n\t\t\t\t\tconst cancelResult = this._cancel([teeState.reason1, teeState.reason2]);\n\t\t\t\t\tteeState._resolve(cancelResult);\n\t\t\t\t}\n\t\t\t\treturn teeState.promise;\n\t\t\t};\n\t\t};\n\n\t\tconst pull = function (controller: ReadableStreamController<T>) {\n\t\t\treturn reader.read().then(function (result: any) {\n\t\t\t\tconst value = result.value;\n\t\t\t\tconst done = result.done;\n\n\t\t\t\tif (done && !teeState.closedOrErrored) {\n\t\t\t\t\tbranch1.requestClose();\n\t\t\t\t\tbranch2.requestClose();\n\n\t\t\t\t\tteeState.closedOrErrored = true;\n\t\t\t\t}\n\n\t\t\t\tif (teeState.closedOrErrored) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!teeState.canceled1) {\n\t\t\t\t\tbranch1.enqueue(value);\n\t\t\t\t}\n\n\t\t\t\tif (!teeState.canceled2) {\n\t\t\t\t\tbranch2.enqueue(value);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tconst cancel1 = createCancelFunction(1);\n\t\tconst cancel2 = createCancelFunction(2);\n\t\tconst underlyingSource1: Source<T> = <Source<T>> {\n\t\t\tpull: pull,\n\t\t\tcancel: cancel1\n\t\t};\n\t\tbranch1 = new ReadableStream(underlyingSource1);\n\n\t\tconst underlyingSource2: Source<T> = <Source<T>> {\n\t\t\tpull: pull,\n\t\t\tcancel: cancel2\n\t\t};\n\t\tbranch2 = new ReadableStream(underlyingSource2);\n\n\t\treader.closed.catch(function (r: any) {\n\t\t\tif (teeState.closedOrErrored) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbranch1.error(r);\n\t\t\tbranch2.error(r);\n\t\t\tteeState.closedOrErrored = true;\n\t\t});\n\n\t\treturn [ branch1, branch2 ];\n\t}\n}\n"]}