{"version":3,"file":"TransformStream.js","sourceRoot":"","sources":["TransformStream.ts"],"names":["TransformStream","TransformStream.constructor","TransformStream.constructor.maybeDoTransform","TransformStream.constructor.transformDone","TransformStream.constructor.abort","TransformStream.constructor.start","TransformStream.constructor.write","TransformStream.constructor.close","TransformStream.constructor.pull","TransformStream.constructor.cancel"],"mappings":"AAAA,8FAA8F;AAC9F,iGAAiG;;;;;;;;;IAGjG,wBAAoB,YAAY,CAAC,CAAA;IACjC,+BAAuC,kBAAkB,CAAC,CAAA;IAE1D,+BAAqC,kBAAkB,CAAC,CAAA;IAkCxD;;;;;;;;;;;OAWG;IACH;QAICA,yBAAYA,WAA4BA;YACvCC,IAAIA,UAAaA,CAACA;YAClBA,IAAIA,SAAqBA,CAACA;YAC1BA,IAAIA,aAAoCA,CAACA;YACzCA,IAAIA,YAAYA,GAAGA,KAAKA,CAACA;YACzBA,IAAIA,gCAAgCA,GAAGA,KAAKA,CAACA;YAC7CA,IAAIA,iBAA6BA,CAACA;YAClCA,IAAIA,aAAoCA,CAACA;YACzCA,IAAIA,aAAoCA,CAACA;YAEzCA;gBACCC,EAAEA,CAACA,CAACA,CAACA,YAAYA,CAACA,CAACA,CAACA;oBACnBA,YAAYA,GAAGA,IAAIA,CAACA;oBACpBA,IAAIA,CAACA;wBACJA,WAAWA,CAACA,SAASA,CAACA,UAAUA,EAAEA,iBAAiBA,EAAEA,aAAaA,CAACA,CAACA;wBACpEA,UAAUA,GAAGA,SAASA,CAACA;wBACvBA,gCAAgCA,GAAGA,KAAKA,CAACA;oBAC1CA,CAAEA;oBAAAA,KAAKA,CAACA,CAACA,CAACA,CAACA,CAACA,CAACA;wBACZA,YAAYA,GAAGA,KAAKA,CAACA;wBACrBA,aAAaA,CAACA,CAACA,CAACA,CAACA;wBACjBA,aAAaA,CAACA,CAACA,CAACA,CAACA;oBAClBA,CAACA;gBACFA,CAACA;YACFA,CAACA;YAEDD;gBACCE,YAAYA,GAAGA,KAAKA,CAACA;gBACrBA,SAASA,EAAEA,CAACA;YACbA,CAACA;YAEDF,IAAIA,CAACA,QAAQA,GAAGA,IAAIA,wBAAcA,CAAeA;gBAChDA,KAAKA;oBACJG,MAAMA,CAACA,iBAAOA,CAACA,OAAOA,EAAEA,CAACA;gBAC1BA,CAACA;gBAEDH,KAAKA,YAACA,KAA4BA;oBACjCI,aAAaA,GAAGA,KAAKA,CAACA;oBACtBA,MAAMA,CAACA,iBAAOA,CAACA,OAAOA,EAAEA,CAACA;gBAC1BA,CAACA;gBAEDJ,KAAKA,YAACA,KAAQA;oBACbK,UAAUA,GAAGA,KAAKA,CAACA;oBACnBA,gCAAgCA,GAAGA,IAAIA,CAACA;oBACxCA,IAAMA,OAAOA,GAAGA,IAAIA,iBAAOA,CAAOA,UAAUA,OAAOA;wBAClD,SAAS,GAAG,OAAO,CAAC;oBACrB,CAAC,CAACA,CAACA;oBACHA,gBAAgBA,EAAEA,CAACA;oBACnBA,MAAMA,CAACA,OAAOA,CAACA;gBAChBA,CAACA;gBAEDL,KAAKA;oBACJM,IAAIA,CAACA;wBACJA,WAAWA,CAACA,KAAKA,CAACA,iBAAiBA,EAAEA,aAAaA,CAACA,CAACA;wBACpDA,MAAMA,CAACA,iBAAOA,CAACA,OAAOA,EAAEA,CAACA;oBAC1BA,CAAEA;oBAAAA,KAAKA,CAACA,CAACA,CAACA,CAACA,CAACA,CAACA;wBACZA,aAAaA,CAACA,CAACA,CAACA,CAACA;wBACjBA,aAAaA,CAACA,CAACA,CAACA,CAACA;wBACjBA,MAAMA,CAACA,iBAAOA,CAACA,MAAMA,CAACA,CAACA,CAACA,CAACA;oBAC1BA,CAACA;gBACFA,CAACA;aACDN,EAAEA,WAAWA,CAACA,gBAAgBA,CAACA,CAACA;YAEjCA,IAAIA,CAACA,QAAQA,GAAGA,IAAIA,wBAAcA,CAAcA;gBAC/CA,KAAKA,YAACA,UAAuCA;oBAC5CI,iBAAiBA,GAAGA,UAAUA,CAACA,OAAOA,CAACA,IAAIA,CAACA,UAAUA,CAACA,CAACA;oBACxDA,aAAaA,GAAGA,UAAUA,CAACA,KAAKA,CAACA,IAAIA,CAACA,UAAUA,CAACA,CAACA;oBAClDA,aAAaA,GAAGA,UAAUA,CAACA,KAAKA,CAACA,IAAIA,CAACA,UAAUA,CAACA,CAACA;oBAClDA,MAAMA,CAACA,iBAAOA,CAACA,OAAOA,EAAEA,CAACA;gBAC1BA,CAACA;gBAEDJ,IAAIA,YAACA,UAAuCA;oBAC3CO,EAAEA,CAACA,CAACA,gCAAgCA,CAACA,CAACA,CAACA;wBACtCA,gBAAgBA,EAAEA,CAACA;oBACpBA,CAACA;oBACDA,MAAMA,CAACA,iBAAOA,CAACA,OAAOA,EAAEA,CAACA;gBAC1BA,CAACA;gBAEDP,MAAMA;oBACLQ,MAAMA,CAACA,iBAAOA,CAACA,OAAOA,EAAEA,CAACA;gBAC1BA,CAACA;aACDR,EAAEA,WAAWA,CAACA,gBAAgBA,CAACA,CAACA;QAClCA,CAACA;QACFD,sBAACA;IAADA,CAACA,AAtFD,IAsFC;IAtFD;qCAsFC,CAAA","sourcesContent":["// This is a simple adaptation to TypeScript of the reference implementation (as of May 2015):\n// https://github.com/whatwg/streams/blob/master/reference-implementation/lib/transform-stream.js\n\nimport { Strategy } from './interfaces';\nimport Promise from '../Promise';\nimport ReadableStream, { Source } from './ReadableStream';\nimport ReadableStreamController from './ReadableStreamController';\nimport WritableStream, { Sink } from './WritableStream';\n\n/**\n * The `Transform` interface defines the requirements for a transform object to be supplied to a\n * {@link TransformStream} instance.\n */\nexport interface Transform<R, W> {\n\t/**\n\t * The `transform` method should accept a chunk, an `enqueueInReadable` function, and a `transformDone` function.\n\t * The chunk is the data to be transformed. The transform function should perform any transform logic on the chunk\n\t * and then call the supplied `enqueueInReadable` function, passing it the transformed data. After that it should\n\t * call the supplied `transformDone` function to notify the `TransformStream` that transformation is complete.\n\t */\n\ttransform(chunk: W, enqueueInReadable: (chunk: R) => void, transformDone: () => void): void;\n\n\t/**\n\t * The `flush` method will be called by the `TransformStream` when its {@link WritableStream} is closed. Any logic\n\t * the transformer may wish to run when the stream is closed can be supplied in this function. Any pending data\n\t * can still be enqueued using the supplied `enqueue` function. When the transformer has finished transforming all\n\t * data and is ready to close the {@link ReadableStream} it should call the supplied `close` function.\n\t */\n\tflush(enqueue: Function, close: Function): void;\n\n\t/**\n\t * If supplied, this strategy will be used for the `Transformer`'s internal {@link ReadableStream}\n\t */\n\treadableStrategy: Strategy<R>;\n\n\t/**\n\t * If supplied, this strategy will be used for the `Transformer`'s internal {@link WritableStream}\n\t */\n\twritableStrategy: Strategy<W>;\n}\n\n/**\n * A `TransformStream` is both readable and writable. Its purpose is to apply some transform logic to everything that\n * is written to it and provide the transformed data via its reader. As such, it requires no `ReadableStream`,\n * `WritableStream`, or `Source` or `Sink` to be supplied - it provides its own.\n *\n * It does require an object that implements the {@link Transform} interface to be supplied. The `transform` method\n * will be applied to all data written to the stream.\n *\n * The readable stream API is available via the `TransformStream`'s `readable` property, which is a\n * {@link ReadableStream}. The writable stream API is available via the `TransformStream`'s `writable` property, which\n * is a {@link WritableStream}.\n */\nexport default class TransformStream<R, W> {\n\treadable: ReadableStream<R>;\n\twritable: WritableStream<W>;\n\n\tconstructor(transformer: Transform<R, W>) {\n\t\tlet writeChunk: W;\n\t\tlet writeDone: () => void;\n\t\tlet errorWritable: (error?: any) => void;\n\t\tlet transforming = false;\n\t\tlet chunkWrittenButNotYetTransformed = false;\n\t\tlet enqueueInReadable: () => void;\n\t\tlet closeReadable: (error?: any) => void;\n\t\tlet errorReadable: (error?: any) => void;\n\n\t\tfunction maybeDoTransform() {\n\t\t\tif (!transforming) {\n\t\t\t\ttransforming = true;\n\t\t\t\ttry {\n\t\t\t\t\ttransformer.transform(writeChunk, enqueueInReadable, transformDone);\n\t\t\t\t\twriteChunk = undefined;\n\t\t\t\t\tchunkWrittenButNotYetTransformed = false;\n\t\t\t\t} catch (e) {\n\t\t\t\t\ttransforming = false;\n\t\t\t\t\terrorWritable(e);\n\t\t\t\t\terrorReadable(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction transformDone() {\n\t\t\ttransforming = false;\n\t\t\twriteDone();\n\t\t}\n\n\t\tthis.writable = new WritableStream<W>(<Sink <W>> {\n\t\t\tabort(): Promise<void> {\n\t\t\t\treturn Promise.resolve();\n\t\t\t},\n\n\t\t\tstart(error: (error?: any) => void) {\n\t\t\t\terrorWritable = error;\n\t\t\t\treturn Promise.resolve();\n\t\t\t},\n\n\t\t\twrite(chunk: W) {\n\t\t\t\twriteChunk = chunk;\n\t\t\t\tchunkWrittenButNotYetTransformed = true;\n\t\t\t\tconst promise = new Promise<void>(function (resolve) {\n\t\t\t\t\twriteDone = resolve;\n\t\t\t\t});\n\t\t\t\tmaybeDoTransform();\n\t\t\t\treturn promise;\n\t\t\t},\n\n\t\t\tclose(): Promise<void> {\n\t\t\t\ttry {\n\t\t\t\t\ttransformer.flush(enqueueInReadable, closeReadable);\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrorWritable(e);\n\t\t\t\t\terrorReadable(e);\n\t\t\t\t\treturn Promise.reject(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}, transformer.writableStrategy);\n\n\t\tthis.readable = new ReadableStream(<Source <R>> {\n\t\t\tstart(controller: ReadableStreamController<R>): Promise<void> {\n\t\t\t\tenqueueInReadable = controller.enqueue.bind(controller);\n\t\t\t\tcloseReadable = controller.close.bind(controller);\n\t\t\t\terrorReadable = controller.error.bind(controller);\n\t\t\t\treturn Promise.resolve();\n\t\t\t},\n\n\t\t\tpull(controller: ReadableStreamController<R>): Promise<void> {\n\t\t\t\tif (chunkWrittenButNotYetTransformed) {\n\t\t\t\t\tmaybeDoTransform();\n\t\t\t\t}\n\t\t\t\treturn Promise.resolve();\n\t\t\t},\n\n\t\t\tcancel(): Promise<void> {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t}, transformer.readableStrategy);\n\t}\n}\n"]}