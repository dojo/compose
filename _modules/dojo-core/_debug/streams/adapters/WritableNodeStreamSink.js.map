{"version":3,"file":"WritableNodeStreamSink.js","sourceRoot":"","sources":["WritableNodeStreamSink.ts"],"names":["WritableNodeStreamSink","WritableNodeStreamSink.constructor","WritableNodeStreamSink._handleError","WritableNodeStreamSink._removeListeners","WritableNodeStreamSink.abort","WritableNodeStreamSink.close","WritableNodeStreamSink.start","WritableNodeStreamSink.write"],"mappings":";;;;;;;;IAAA,wBAAoB,eAAe,CAAC,CAAA;IAKpC;QAOCA,gCAAYA,UAAiCA,EAAEA,QAAqBA;YAArBC,wBAAqBA,GAArBA,aAAqBA;YACnEA,IAAIA,CAACA,SAASA,GAAGA,KAAKA,CAACA;YAEvBA,IAAIA,CAACA,SAASA,GAAGA,QAAQA,CAACA;YAC1BA,IAAIA,CAACA,WAAWA,GAAGA,UAAUA,CAACA;YAC9BA,IAAIA,CAACA,QAAQA,GAAGA,IAAIA,CAACA,YAAYA,CAACA,IAAIA,CAACA,IAAIA,CAACA,CAACA;YAC7CA,IAAIA,CAACA,WAAWA,CAACA,EAAEA,CAACA,OAAOA,EAAEA,IAAIA,CAACA,QAAQA,CAACA,CAACA;QAC7CA,CAACA;QAESD,6CAAYA,GAAtBA,UAAuBA,KAAYA;YAClCE,IAAIA,CAACA,SAASA,GAAGA,IAAIA,CAACA;YACtBA,IAAIA,CAACA,gBAAgBA,EAAEA,CAACA;YAExBA,EAAEA,CAACA,CAACA,IAAIA,CAACA,mBAAmBA,CAACA,CAACA,CAACA;gBAC9BA,IAAIA,CAACA,mBAAmBA,CAACA,KAAKA,CAACA,CAACA;gBAChCA,IAAIA,CAACA,mBAAmBA,GAAGA,SAASA,CAACA;YACtCA,CAACA;YAEDA,MAAMA,KAAKA,CAACA;QACbA,CAACA;QAESF,iDAAgBA,GAA1BA;YACCG,IAAIA,CAACA,WAAWA,CAACA,cAAcA,CAACA,OAAOA,EAAEA,IAAIA,CAACA,QAAQA,CAACA,CAACA;QACzDA,CAACA;QAEDH,sCAAKA,GAALA,UAAMA,MAAWA;YAChBI,2CAA2CA;YAC3CA,MAAMA,CAACA,IAAIA,CAACA,KAAKA,EAAEA,CAACA;QACrBA,CAACA;QAEDJ,sCAAKA,GAALA;YAAAK,iBAiBCA;YAhBAA,IAAIA,CAACA,SAASA,GAAGA,IAAIA,CAACA;YACtBA,IAAIA,CAACA,gBAAgBA,EAAEA,CAACA;YAExBA,MAAMA,CAACA,IAAIA,iBAAOA,CAAOA,UAACA,OAAOA,EAAEA,MAAMA;gBACxCA,mEAAmEA;gBACnEA,qDAAqDA;gBACrDA,yDAAyDA;gBACzDA,KAAIA,CAACA,WAAWA,CAACA,GAAGA,CAACA,IAAIA,EAAEA,IAAIA,EAAEA,UAACA,KAAYA;oBAC7CA,EAAEA,CAACA,CAACA,KAAKA,CAACA,CAACA,CAACA;wBACXA,MAAMA,CAACA,KAAKA,CAACA,CAACA;oBACfA,CAACA;oBACDA,IAAIA,CAACA,CAACA;wBACLA,OAAOA,EAAEA,CAACA;oBACXA,CAACA;gBACFA,CAACA,CAACA,CAACA;YACJA,CAACA,CAACA,CAACA;QACJA,CAACA;QAEDL,sCAAKA,GAALA;YACCM,EAAEA,CAACA,CAACA,IAAIA,CAACA,SAASA,CAACA,CAACA,CAACA;gBACpBA,MAAMA,CAACA,iBAAOA,CAACA,MAAMA,CAACA,IAAIA,KAAKA,CAACA,kBAAkBA,CAACA,CAACA,CAACA;YACtDA,CAACA;YAEDA,MAAMA,CAACA,iBAAOA,CAACA,OAAOA,EAAEA,CAACA;QAC1BA,CAACA;QAEDN,sCAAKA,GAALA,UAAMA,KAAaA;YAAnBO,iBAkBCA;YAjBAA,EAAEA,CAACA,CAACA,IAAIA,CAACA,SAASA,CAACA,CAACA,CAACA;gBACpBA,MAAMA,CAACA,iBAAOA,CAACA,MAAMA,CAACA,IAAIA,KAAKA,CAACA,kBAAkBA,CAACA,CAACA,CAACA;YACtDA,CAACA;YAEDA,MAAMA,CAACA,IAAIA,iBAAOA,CAAOA,UAACA,OAAOA,EAAEA,MAAMA;gBACxCA,KAAIA,CAACA,mBAAmBA,GAAGA,MAAMA,CAACA;gBAElCA,KAAIA,CAACA,WAAWA,CAACA,KAAKA,CAACA,KAAKA,EAAEA,KAAIA,CAACA,SAASA,EAAEA,UAACA,KAAaA;oBAC3DA,EAAEA,CAACA,CAACA,KAAKA,CAACA,CAACA,CAACA;wBACXA,KAAIA,CAACA,YAAYA,CAACA,KAAKA,CAACA,CAACA;oBAC1BA,CAACA;oBACDA,IAAIA,CAACA,CAACA;wBACLA,KAAIA,CAACA,mBAAmBA,GAAGA,SAASA,CAACA;wBACrCA,OAAOA,EAAEA,CAACA;oBACXA,CAACA;gBACFA,CAACA,CAACA,CAACA;YACJA,CAACA,CAACA,CAACA;QACJA,CAACA;QACFP,6BAACA;IAADA,CAACA,AAnFD,IAmFC;IAnFD;4CAmFC,CAAA","sourcesContent":["import Promise from '../../Promise';\nimport { Sink } from '../WritableStream';\n\nexport type NodeSourceType = Buffer | string;\n\nexport default class WritableNodeStreamSink implements Sink<NodeSourceType> {\n\tprotected _encoding: string;\n\tprotected _isClosed: boolean;\n\tprotected _nodeStream: NodeJS.WritableStream;\n\tprotected _onError: (error: Error) => void;\n\tprotected _rejectWritePromise: Function;\n\n\tconstructor(nodeStream: NodeJS.WritableStream, encoding: string = '') {\n\t\tthis._isClosed = false;\n\n\t\tthis._encoding = encoding;\n\t\tthis._nodeStream = nodeStream;\n\t\tthis._onError = this._handleError.bind(this);\n\t\tthis._nodeStream.on('error', this._onError);\n\t}\n\n\tprotected _handleError(error: Error): void {\n\t\tthis._isClosed = true;\n\t\tthis._removeListeners();\n\n\t\tif (this._rejectWritePromise) {\n\t\t\tthis._rejectWritePromise(error);\n\t\t\tthis._rejectWritePromise = undefined;\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\tprotected _removeListeners(): void {\n\t\tthis._nodeStream.removeListener('error', this._onError);\n\t}\n\n\tabort(reason: any): Promise<void> {\n\t\t// TODO: is there anything else to do here?\n\t\treturn this.close();\n\t}\n\n\tclose(): Promise<void> {\n\t\tthis._isClosed = true;\n\t\tthis._removeListeners();\n\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\t// TODO: if the node stream returns an error from 'end', should we:\n\t\t\t// 1. reject this.close with the error? (implemented)\n\t\t\t// 2. put 'this' into an error state? (this._handleError)\n\t\t\tthis._nodeStream.end(null, null, (error: Error) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tstart(): Promise<void> {\n\t\tif (this._isClosed) {\n\t\t\treturn Promise.reject(new Error('Stream is closed'));\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\twrite(chunk: string): Promise<void> {\n\t\tif (this._isClosed) {\n\t\t\treturn Promise.reject(new Error('Stream is closed'));\n\t\t}\n\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tthis._rejectWritePromise = reject;\n\n\t\t\tthis._nodeStream.write(chunk, this._encoding, (error?: Error) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis._handleError(error);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._rejectWritePromise = undefined;\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n"]}