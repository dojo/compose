{"version":3,"file":"ReadableStreamController.js","sourceRoot":"","sources":["ReadableStreamController.ts"],"names":["isReadableStreamController","ReadableStreamController","ReadableStreamController.constructor","ReadableStreamController.desiredSize","ReadableStreamController.close","ReadableStreamController.enqueue","ReadableStreamController.error"],"mappings":"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","sourcesContent":["import ReadableStream, { State } from './ReadableStream';\n\n// 3.5.9-1 has been ignored\nexport function isReadableStreamController(x: any): boolean {\n\treturn Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream');\n}\n\nexport default class ReadableStreamController<T> {\n\tprivate _controlledReadableStream: ReadableStream<T>;\n\n\t/**\n\t * Returns a number indicating how much additional data can be pushed by the source to the stream's queue before it\n\t * exceeds its `highWaterMark`. An underlying source should use this information to determine when and how to apply\n\t * backpressure.\n\t *\n\t * @returns The stream's strategy's `highWaterMark` value minus the queue size\n\t */\n\t// 3.3.4.1. get desiredSize\n\tget desiredSize(): number {\n\t\treturn this._controlledReadableStream.desiredSize;\n\t}\n\n\tconstructor(stream: ReadableStream<T>) {\n\t\tif (!stream.readable) {\n\t\t\tthrow new TypeError('3.3.3-1: ReadableStreamController can only be constructed with a ReadableStream instance');\n\t\t}\n\n\t\tif (stream.controller !== undefined) {\n\t\t\tthrow new TypeError('ReadableStreamController instances can only be created by the ReadableStream constructor');\n\t\t}\n\n\t\tthis._controlledReadableStream = stream;\n\t}\n\n\t/**\n\t * A source should call this method when it has no more data to provide. After this method is called, the stream\n\t * will provided any queued data to the reader, but once the stream's queue is exhausted the stream will be closed\n\t * and no more data can be read from it.\n\t */\n\tclose(): void {\n\t\tif (!isReadableStreamController(this)) {\n\t\t\tthrow new TypeError('3.3.4.2-1: ReadableStreamController#close can only be used on a ReadableStreamController');\n\t\t}\n\n\t\tconst stream = this._controlledReadableStream;\n\t\tif (stream.closeRequested) {\n\t\t\tthrow new TypeError('3.3.4.2-3: The stream has already been closed; do not close it again!');\n\t\t}\n\n\t\tif (stream.state === State.Errored) {\n\t\t\tthrow new TypeError('3.3.4.2-4: The stream is in an errored state and cannot be closed');\n\t\t}\n\n\t\treturn stream.requestClose();\n\t}\n\n\t/**\n\t * A source should call this method to provide data to the stream.\n\t *\n\t * @param chunk The data to provide to the stream\n\t */\n\tenqueue(chunk: T): void {\n\t\tif (!isReadableStreamController(this)) {\n\t\t\tthrow new TypeError('3.3.4.3-1: ReadableStreamController#enqueue can only be used on a ReadableStreamController');\n\t\t}\n\n\t\tconst stream = this._controlledReadableStream;\n\n\t\tif (stream.state === State.Errored) {\n\t\t\tthrow stream.storedError;\n\t\t}\n\n\t\tif (stream.closeRequested) {\n\t\t\tthrow new TypeError('3.3.4.3-4: stream is draining');\n\t\t}\n\n\t\tstream.enqueue(chunk);\n\t}\n\n\t/**\n\t * A source should call this method to indicate an error condition to the stream that irreparably disrupts the\n\t * source's (and thus the stream's) ability to provide all the intended data.\n\t *\n\t * @param error An error object representing the error condition in the source\n\t */\n\terror(error: Error): void {\n\t\tif (!isReadableStreamController(this)) {\n\t\t\tthrow new TypeError('3.3.4.3-1: ReadableStreamController#enqueue can only be used on a ReadableStreamController');\n\t\t}\n\n\t\tif (this._controlledReadableStream.state !== State.Readable) {\n\t\t\tthrow new TypeError(`3.3.4.3-2: the stream is ${this._controlledReadableStream.state} and so cannot be errored`);\n\t\t}\n\t\t// return errorReadableStream(this._controlledReadableStream, e);\n\t\tthis._controlledReadableStream.error(error);\n\t}\n}\n"]}