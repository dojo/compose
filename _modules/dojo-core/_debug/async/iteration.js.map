{"version":3,"file":"iteration.js","sourceRoot":"","sources":["iteration.ts"],"names":["processValuesAndCallback","findNextValueIndex","findLastValueIndex","generalReduce","next","testAndHaltOnCondition","every","filter","find","findIndex","map","reduce","reduceRight","series","some"],"mappings":"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","sourcesContent":["import Promise, { Thenable } from '../Promise';\nimport * as array from '../array';\nimport { ArrayLike } from '../array';\n\n/**\n * Processes all items and then applies the callback to each item and eventually returns an object containing the\n * processed values and callback results\n * @param items a list of synchronous/asynchronous values to process\n * @param callback a callback that maps values to synchronous/asynchronous results\n * @return a list of objects holding the synchronous values and synchronous results.\n */\nfunction processValuesAndCallback<T, U>(items: (T | Promise<T>)[], callback: Mapper<T, U>): Promise<{ values: T[]; results: U[] }> {\n\treturn Promise.all<T>(items)\n\t\t.then(function (results) {\n\t\t\tlet pass: (U | Promise<U>)[] = Array.prototype.map.call(results, callback);\n\t\t\treturn Promise.all<U>(pass)\n\t\t\t\t.then<{ values: T[]; results: U[] }>(function (pass) {\n\t\t\t\t\treturn { values: results, results: pass };\n\t\t\t\t});\n\t\t});\n}\n\n/**\n * Finds the index of the next value in a sparse array-like object\n * @param list the sparse array-like object\n * @param offset the starting offset\n * @return {number} the offset of the next index with a value; or -1 if not found\n */\nfunction findNextValueIndex<T>(list: ArrayLike<T>, offset: number = -1): number {\n\toffset++;\n\tfor (let length = list.length; offset < length; offset++) {\n\t\tif (offset in list) {\n\t\t\treturn offset;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction findLastValueIndex<T>(list: ArrayLike<T>, offset?: number): number {\n\toffset = (offset === undefined ? list.length : offset) - 1;\n\tfor (; offset >= 0; offset--) {\n\t\tif (offset in list) {\n\t\t\treturn offset;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction generalReduce<T, U>(findNextIndex: (list: ArrayLike<any>, offset?: number) => number, items: (T | Promise<T>)[], callback: Reducer<T, U>, initialValue?: U): Promise<U> {\n\tconst hasInitialValue = arguments.length > 3;\n\treturn Promise.all<T>(items)\n\t\t.then(function (results) {\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tlet i: number;\n\t\t\t\tfunction next(currentValue: U): void {\n\t\t\t\t\ti = findNextIndex(items, i);\n\t\t\t\t\tif (i >= 0) {\n\t\t\t\t\t\tconst result = callback(currentValue, results[i], i, results);\n\n\t\t\t\t\t\tif ( (<Thenable<U>> result).then) {\n\t\t\t\t\t\t\t(<Thenable<U>> result).then(next, reject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnext(<U> result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresolve(currentValue);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlet value: U;\n\t\t\t\tif (hasInitialValue) {\n\t\t\t\t\tvalue = initialValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti = findNextIndex(items);\n\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tthrow new Error('reduce array with no initial value');\n\t\t\t\t\t}\n\t\t\t\t\tvalue = <any> results[i];\n\t\t\t\t}\n\t\t\t\tnext(value);\n\t\t\t});\n\t\t});\n}\n\nfunction testAndHaltOnCondition<T>(condition: boolean, items: (T | Promise<T>)[], callback: Filterer<T>): Promise<boolean> {\n\treturn Promise.all<T>(items).then(function (results) {\n\t\treturn new Promise<boolean>(function(resolve) {\n\t\t\tlet result: (boolean | Thenable<boolean>);\n\t\t\tlet pendingCount = 0;\n\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\tresult = callback(results[i], i, results);\n\t\t\t\tif (result === condition) {\n\t\t\t\t\treturn resolve(result);\n\t\t\t\t}\n\t\t\t\telse if ((<Thenable<boolean>> result).then) {\n\t\t\t\t\tpendingCount++;\n\t\t\t\t\t(<Thenable<boolean>> result).then(function (result) {\n\t\t\t\t\t\tif (result === condition) {\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpendingCount--;\n\t\t\t\t\t\tif (pendingCount === 0) {\n\t\t\t\t\t\t\tresolve(!condition);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pendingCount === 0) {\n\t\t\t\tresolve(!condition);\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Test whether all elements in the array pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns true if all values pass; otherwise false\n */\nexport function every<T>(items: (T | Promise<T>)[], callback: Filterer<T>): Promise<boolean> {\n\treturn testAndHaltOnCondition(false, items, callback);\n}\n\n/**\n * Returns an array of elements which pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns a new array with only values that have passed\n */\nexport function filter<T>(items: (T | Promise<T>)[], callback: Filterer<T>): Promise<T[]> {\n\treturn processValuesAndCallback(items, callback).then<T[]>(function ({ results, values }) {\n\t\tlet arr: T[] = [];\n\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\tresults[i] && arr.push(values[i]);\n\t\t}\n\t\treturn arr;\n\t});\n}\n\n/**\n * Find the first value matching a filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the item or undefined if a match is not found\n */\nexport function find<T>(items: (T | Promise<T>)[], callback: Filterer<T>): Promise<T> {\n\treturn findIndex<T>(items, callback).then(function (i) {\n\t\treturn i >= 0 ? items[i] : undefined;\n\t});\n}\n\n/**\n * Find the first index with a value matching the filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the index of the matching item or -1 if a match is not found\n */\nexport function findIndex<T>(items: (T | Promise<T>)[], callback: Filterer<T>): Promise<number> {\n\t// TODO we can improve this by returning immediately\n\treturn processValuesAndCallback(items, callback).then<number>(function ({ results }) {\n\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\tif (results[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t});\n}\n\n/**\n * transform a list of items using a mapper function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous transform function\n * @return a promise eventually containing a collection of each transformed value\n */\nexport function map<T, U>(items: (T | Promise<T>)[], callback: Mapper<T, U>): Promise<U[]> {\n\treturn processValuesAndCallback<T, U>(items, callback)\n\t\t\t.then<U[]>(function ({ results }) {\n\t\t\t\treturn results;\n\t\t\t});\n}\n\n/**\n * reduce a list of items down to a single value\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous reducer function\n * @param [initialValue] the first value to pass to the callback\n * @return a promise eventually containing a value that is the result of the reduction\n */\nexport function reduce<T, U>(items: (T | Promise<T>)[], callback: Reducer<T, U>, initialValue?: U): Promise<U> {\n\tlet args: any[] = <any[]> array.from(arguments);\n\targs.unshift(findNextValueIndex);\n\treturn generalReduce.apply(this, args);\n}\n\nexport function reduceRight<T, U>(items: (T | Promise<T>)[], callback: Reducer<T, U>, initialValue?: U): Promise<U> {\n\tlet args: any[] = <any[]> array.from(arguments);\n\targs.unshift(findLastValueIndex);\n\treturn generalReduce.apply(this, args);\n}\n\nexport function series<T, U>(items: (T | Promise<T>)[], operation: Mapper<T, U>): Promise<U[]> {\n\treturn generalReduce(findNextValueIndex, items, function (previousValue, currentValue, index, array) {\n\t\tconst result = operation(currentValue, index, array);\n\n\t\tif ((<Thenable<U>> result).then) {\n\t\t\treturn (<Thenable<U>> result).then(function (value) {\n\t\t\t\tpreviousValue.push(value);\n\t\t\t\treturn previousValue;\n\t\t\t});\n\t\t}\n\n\t\tpreviousValue.push(result);\n\t\treturn previousValue;\n\t}, []);\n}\n\nexport function some<T>(items: Array<T | Promise<T>>, callback: Filterer<T>): Promise<boolean> {\n\treturn testAndHaltOnCondition<T>(true, items, callback);\n}\n\nexport interface Filterer<T> extends Mapper<T, boolean> {}\n\nexport interface Mapper<T, U> {\n\t(value: T, index: number, array: T[]): (U | Thenable<U>);\n}\n\nexport interface Reducer<T, U> {\n\t(previousValue: U, currentValue: T, index: number, array: T[]): (U | Thenable<U>);\n}\n"]}