{"version":3,"file":"Promise.js","sourceRoot":"","sources":["Promise.ts"],"names":["unwrapPromises","isThenable","PromiseShim","PromiseShim.constructor","PromiseShim.all","fulfill","finish","processItem","PromiseShim.race","PromiseShim.reject","PromiseShim.resolve","Promise","Promise.constructor","Promise.all","Promise.race","Promise.reject","Promise.resolve","Promise.copy","Promise.catch","Promise.finally","Promise.finally.handler","Promise.state","Promise.then","State"],"mappings":"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IAAIA,CAACA;gBAClBA,CAACA;gBACDA,IAAIA,CAACA,CAACA;oBACLA,MAAMA,CAACA,QAAQA,EAAEA,KAAKA,CAACA,CAACA;gBACzBA,CAACA;YACFA,CAACA,CAACA;YAEFA,IAAIA,CAACA,IAAIA,GAAGA,UACXA,WAAiDA,EACjDA,UAAqDA;gBAErDA,MAAMA,CAACA,IAAIA,WAAWA,CAAIA,UAACA,OAAOA,EAAEA,MAAMA;oBACzCA,mGAAmGA;oBACnGA,uGAAuGA;oBACvGA,cAAcA;oBACdA,YAAYA,CAACA;wBACZA,IAAMA,QAAQA,GAAyBA,KAAIA,CAACA,KAAKA,KAAKA,KAAKA,CAACA,QAAQA,GAAGA,UAAUA,GAAGA,WAAWA,CAACA;wBAEhGA,EAAEA,CAACA,CAACA,OAAOA,QAAQA,KAAKA,UAAUA,CAACA,CAACA,CAACA;4BACpCA,IAAIA,CAACA;gCACJA,OAAOA,CAACA,QAAQA,CAACA,KAAIA,CAACA,aAAaA,CAACA,CAACA,CAACA;4BACvCA,CACAA;4BAAAA,KAAKA,CAACA,CAACA,KAAKA,CAACA,CAACA,CAACA;gCACdA,MAAMA,CAACA,KAAKA,CAACA,CAACA;4BACfA,CAACA;wBACFA,CAACA;wBACDA,IAAIA,CAACA,EAAEA,CAACA,CAACA,KAAIA,CAACA,KAAKA,KAAKA,KAAKA,CAACA,QAAQA,CAACA,CAACA,CAACA;4BACxCA,MAAMA,CAACA,KAAIA,CAACA,aAAaA,CAACA,CAACA;wBAC5BA,CAACA;wBACDA,IAAIA,CAACA,CAACA;4BACLA,OAAOA,CAACA,KAAIA,CAACA,aAAaA,CAACA,CAACA;wBAC7BA,CAACA;oBACFA,CAACA,CAACA,CAACA;gBACJA,CAACA,CAACA,CAACA;YACJA,CAACA,CAACA;YAEFA,IAAIA,CAACA;gBACWA,QAASA,CACvBA,OAAOA,CAACA,IAAIA,CAACA,IAAIA,EAAEA,KAAKA,CAACA,SAASA,CAACA,EACnCA,OAAOA,CAACA,IAAIA,CAACA,IAAIA,EAAEA,KAAKA,CAACA,QAAQA,CAACA,CAClCA,CAACA;YACHA,CACA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","sourcesContent":["import { queueMicroTask } from './queue';\nimport global from './global';\nimport has from './has';\n\n/**\n * Copies an array of values, replacing any PlatformPromises in the copy with unwrapped global.Promises. This is necessary\n * for .all and .race so that the native promise doesn't treat the PlatformPromises like generic thenables.\n */\nfunction unwrapPromises(items: any[]): any[] {\n\tconst unwrapped: typeof items = [];\n\tconst count = items.length;\n\tfor (let i = 0; i < count; i++) {\n\t\tif (!(i in items)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet item = items[i];\n\t\tunwrapped[i] = item instanceof Promise ? item.promise : item;\n\t}\n\treturn unwrapped;\n}\n\n/**\n * Executor is the interface for functions used to initialize a Promise.\n */\nexport interface Executor<T> {\n\t(resolve: (value?: T | Thenable<T>) => void, reject: (reason?: any) => void): void;\n}\n\n/**\n * Returns true if a given value has a `then` method.\n */\nexport function isThenable(value: any) {\n\treturn value && typeof value.then === 'function';\n}\n\n/**\n * PromiseShim is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n * not intended to be used directly.\n *\n * @borrows Promise.all as PromiseShim.all\n * @borrows Promise.race as PromiseShim.race\n * @borrows Promise.reject as PromiseShim.reject\n * @borrows Promise.resolve as PromiseShim.resolve\n * @borrows Promise#catch as PromiseShim#catch\n * @borrows Promise#then as PromiseShim#then\n */\nexport class PromiseShim<T> implements Thenable<T> {\n\tstatic all<T>(items: (T | Thenable<T>)[]): PromiseShim<T[]> {\n\t\treturn new this(function (resolve, reject) {\n\t\t\tconst values: T[] = [];\n\t\t\tlet complete = 0;\n\t\t\tlet total = 0;\n\t\t\tlet populating = true;\n\n\t\t\tfunction fulfill(index: number, value: any): void {\n\t\t\t\tvalues[index] = value;\n\t\t\t\t++complete;\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t\tfunction finish(): void {\n\t\t\t\tif (populating || complete < total) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(values);\n\t\t\t}\n\n\t\t\tfunction processItem(index: number, item: (T | Thenable<T>)): void {\n\t\t\t\t++total;\n\t\t\t\tif (item instanceof PromiseShim) {\n\t\t\t\t\t// If an item PromiseShim rejects, this PromiseShim is immediately rejected with the item\n\t\t\t\t\t// PromiseShim's rejection error.\n\t\t\t\t\titem.then(fulfill.bind(null, index), reject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tPromiseShim.resolve(item).then(fulfill.bind(null, index));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet count = items.length;\n\t\t\tfor (let i = 0; i < count; ++i) {\n\t\t\t\tprocessItem(i, items[i]);\n\t\t\t}\n\t\t\tpopulating = false;\n\n\t\t\tfinish();\n\t\t});\n\t}\n\n\tstatic race<T>(items: (T | Thenable<T>)[]): PromiseShim<T> {\n\t\treturn new this(function (resolve, reject) {\n\t\t\tconst count = items.length;\n\t\t\tlet item: (T | Thenable<T>);\n\n\t\t\tfor (let i = 0; i < count; ++i) {\n\t\t\t\titem = items[i];\n\n\t\t\t\tif (item instanceof PromiseShim) {\n\t\t\t\t\t// If a PromiseShim item rejects, this PromiseShim is immediately rejected with the item\n\t\t\t\t\t// PromiseShim's rejection error.\n\t\t\t\t\titem.then(resolve, reject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tPromiseShim.resolve(item).then(resolve);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic reject<T>(reason?: Error): PromiseShim<T> {\n\t\treturn new this(function (resolve, reject) {\n\t\t\treject(reason);\n\t\t});\n\t}\n\n\tstatic resolve(): PromiseShim<void>;\n\tstatic resolve<T>(value: (T | Thenable<T>)): PromiseShim<T>;\n\tstatic resolve<T>(value?: any): PromiseShim<T> {\n\t\treturn new this(function (resolve) {\n\t\t\tresolve(<T> value);\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new PromiseShim.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the PromiseShim is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\tconstructor(executor: Executor<T>) {\n\t\t/**\n\t\t * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t\t */\n\t\tlet isChained = false;\n\n\t\t/**\n\t\t * Whether or not this promise is in a resolved state.\n\t\t */\n\t\tconst isResolved = (): boolean => {\n\t\t\treturn this.state !== State.Pending || isChained;\n\t\t};\n\n\t\t/**\n\t\t * Callbacks that should be invoked once the asynchronous operation has completed.\n\t\t */\n\t\tlet callbacks: Array<() => void> = [];\n\n\t\t/**\n\t\t * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t\t * enqueues callbacks for execution on the next event loop turn.\n\t\t */\n\t\tlet whenFinished = function (callback: () => void): void {\n\t\t\tcallbacks.push(callback);\n\t\t};\n\n\t\t/**\n\t\t * Settles this promise.\n\t\t *\n\t\t * @param newState The resolved state for this promise.\n\t\t * @param {T|Error} value The resolved value for this promise.\n\t\t */\n\t\tconst settle = (newState: State, value: any): void => {\n\t\t\t// A promise can only be settled once.\n\t\t\tif (this.state !== State.Pending) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.state = newState;\n\t\t\tthis.resolvedValue = value;\n\t\t\twhenFinished = queueMicroTask;\n\n\t\t\t// Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t\t\t// wait an extra turn.\n\t\t\tif (callbacks.length > 0) {\n\t\t\t\tqueueMicroTask(function (): void {\n\t\t\t\t\tlet count = callbacks.length;\n\t\t\t\t\tfor (let i = 0; i < count; ++i) {\n\t\t\t\t\t\tcallbacks[i].call(null);\n\t\t\t\t\t}\n\t\t\t\t\tcallbacks = null;\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Resolves this promise.\n\t\t *\n\t\t * @param newState The resolved state for this promise.\n\t\t * @param {T|Error} value The resolved value for this promise.\n\t\t */\n\t\tconst resolve = (newState: State, value: any): void => {\n\t\t\tif (isResolved()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isThenable(value)) {\n\t\t\t\tvalue.then(\n\t\t\t\t\tsettle.bind(null, State.Fulfilled),\n\t\t\t\t\tsettle.bind(null, State.Rejected)\n\t\t\t\t);\n\t\t\t\tisChained = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsettle(newState, value);\n\t\t\t}\n\t\t};\n\n\t\tthis.then = <U>(\n\t\t\tonFulfilled?: (value?: T) => (U | PromiseShim<U>),\n\t\t\tonRejected?: (reason?: Error) => (U | PromiseShim<U>)\n\t\t): PromiseShim<U> => {\n\t\t\treturn new PromiseShim<U>((resolve, reject) => {\n\t\t\t\t// whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t\t\t\t// promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t\t\t\t// event loop.\n\t\t\t\twhenFinished(() => {\n\t\t\t\t\tconst callback: (value?: any) => any = this.state === State.Rejected ? onRejected : onFulfilled;\n\n\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresolve(callback(this.resolvedValue));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.state === State.Rejected) {\n\t\t\t\t\t\treject(this.resolvedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresolve(this.resolvedValue);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\ttry {\n\t\t\t(<Executor<T>> executor)(\n\t\t\t\tresolve.bind(null, State.Fulfilled),\n\t\t\t\tresolve.bind(null, State.Rejected)\n\t\t\t);\n\t\t}\n\t\tcatch (error) {\n\t\t\tsettle(State.Rejected, error);\n\t\t}\n\t}\n\n\t/**\n\t * The current state of this promise.\n\t */\n\tprivate state = State.Pending;\n\n\t/**\n\t * The resolved value for this promise.\n\t *\n\t * @type {T|Error}\n\t */\n\tprivate resolvedValue: any;\n\n\tthen: <U>(\n\t\tonFulfilled?: (value?: T) => (U | Thenable<U>),\n\t\tonRejected?: (reason?: Error) => (U | Thenable<U>)\n\t) => PromiseShim<U>;\n}\n\n/**\n * PlatformPromise is a very thin wrapper around either a native promise implementation or PromiseShim.\n */\nexport default class Promise<T> implements Thenable<T> {\n\t/**\n\t * Points to the promise constructor this platform should use.\n\t */\n\tstatic PromiseConstructor = has('promise') ? global.Promise : PromiseShim;\n\n\t/**\n\t * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n\t * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n\t * iterable. Iterable values that are not promises are converted to promises using PromiseShim.resolve.\n\t *\n\t * @example\n\t * PromiseShim.all([ PromiseShim.resolve('foo'), 'bar' ]).then(function (value) {\n\t *     value[0] === 'foo'; // true\n\t *     value[1] === 'bar'; // true\n\t * });\n\t *\n\t * @example\n\t * PromiseShim.all({\n\t *     foo: PromiseShim.resolve('foo'),\n\t *     bar: 'bar'\n\t * }).then((value) => {\n\t *     value.foo === 'foo'; // true\n\t *     value.bar === 'bar'; // true\n\t * });\n\t */\n\tstatic all<T>(items: (T | Thenable<T>)[]): Promise<T[]> {\n\t\treturn this.copy(Promise.PromiseConstructor.all(unwrapPromises(items)));\n\t}\n\n\t/**\n\t * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n\t * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n\t * the iterable that are not Promises are converted to Promises with PromiseShim.resolve.\n\t *\n\t * @example\n\t * PromiseShim.race([ PromiseShim.resolve('foo'), PromiseShim.resolve('bar') ]).then((value) => {\n\t *     value === 'foo'; // true\n\t * });\n\t *\n\t * @example\n\t * PromiseShim.race({\n\t *     foo: PromiseShim.resolve('foo'),\n\t *     bar: PromiseShim.resolve('bar')\n\t * }).then((value) => {\n\t *     value === 'foo'; // true\n\t * });\n\t */\n\tstatic race<T>(items: (T | Thenable<T>)[]): Promise<T> {\n\t\treturn this.copy(Promise.PromiseConstructor.race(unwrapPromises(items)));\n\t}\n\n\t/**\n\t * Creates a new promise that is rejected with the given error.\n\t */\n\tstatic reject<T>(reason: Error): Promise<any> {\n\t\treturn this.copy(Promise.PromiseConstructor.reject(reason));\n\t}\n\n\t/**\n\t * Creates a new promise that is resolved with the given value. If the passed value is already a PromiseShim, it\n\t * will be returned as-is.\n\t */\n\tstatic resolve(): Promise<void>;\n\tstatic resolve<T>(value: (T | Thenable<T>)): Promise<T>;\n\tstatic resolve<T>(value?: any): Promise<T> {\n\t\tif (value instanceof Promise) {\n\t\t\treturn value;\n\t\t}\n\t\treturn this.copy(Promise.PromiseConstructor.resolve(value));\n\t}\n\n\t/**\n\t * Copies another Promise, taking on its inner state.\n\t */\n\tprotected static copy<U>(other: Promise<U>): Promise<U> {\n\t\tconst promise = Object.create(this.prototype, {\n\t\t\tpromise: { value: other instanceof Promise.PromiseConstructor ? other : other.promise }\n\t\t});\n\n\t\tpromise._state = State.Pending;\n\t\tpromise.promise.then(\n\t\t\tfunction () { promise._state = State.Fulfilled; },\n\t\t\tfunction () { promise._state = State.Rejected; }\n\t\t);\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Creates a new Promise.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the PromiseShim is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\tconstructor(executor: Executor<T>) {\n\t\t// Wrap the executor to verify that the the resolution value isn't this promise. Since any incoming promise\n\t\t// should be wrapped, the native resolver can't automatically detect self-resolution.\n\t\tthis.promise = new Promise.PromiseConstructor(<Executor<T>> ((resolve, reject) => {\n\t\t\texecutor(\n\t\t\t\t(value) => {\n\t\t\t\t\tif (value === this) {\n\t\t\t\t\t\treject(new TypeError('Cannot chain a promise to itself'));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (reason): void {\n\t\t\t\t\treject(reason);\n\t\t\t\t}\n\t\t\t);\n\t\t}));\n\n\t\tthis._state = State.Pending;\n\t\tthis.promise.then(\n\t\t\t() => { this._state = State.Fulfilled; },\n\t\t\t() => { this._state = State.Rejected; }\n\t\t);\n\t}\n\n\t/**\n\t * An object wrapped by this class that actually implements the Promise API.\n\t */\n\tprivate promise: any;\n\n\t/**\n\t * The internal state of this promise. This may be updated directly by subclasses.\n\t */\n\tprotected _state: State;\n\n\t/**\n\t * Adds a callback to the promise to be invoked when the asynchronous operation throws an error.\n\t */\n\tcatch<U>(onRejected: (reason?: Error) => (U | Thenable<U>)): Promise<U> {\n\t\treturn this.then<U>(null, onRejected);\n\t}\n\n\t/**\n\t * Allows for cleanup actions to be performed after resolution of a Promise.\n\t */\n\tfinally(callback: () => void | Thenable<any>): Promise<T> {\n\t\t// Handler to be used for fulfillment and rejection; whether it was fulfilled or rejected is explicitly\n\t\t// indicated by the first argument\n\t\tfunction handler(rejected: boolean, valueOrError: any) {\n\t\t\t// If callback throws, the handler will throw\n\t\t\tconst result = callback();\n\t\t\tif (isThenable(result)) {\n\t\t\t\t// If callback returns a Thenable that rejects, return the rejection. Otherwise, return or throw the\n\t\t\t\t// incoming value as appropriate when the Thenable resolves.\n\t\t\t\treturn Promise.resolve(result).then(function () {\n\t\t\t\t\tif (rejected) {\n\t\t\t\t\t\tthrow valueOrError;\n\t\t\t\t\t}\n\t\t\t\t\treturn valueOrError;\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// If callback returns a non-Thenable, return or throw the incoming value as appropriate.\n\t\t\t\tif (rejected) {\n\t\t\t\t\tthrow valueOrError;\n\t\t\t\t}\n\t\t\t\treturn valueOrError;\n\t\t\t}\n\t\t};\n\n\t\treturn this.then<T>(handler.bind(null, false), handler.bind(null, true));\n\t}\n\n\t/**\n\t * The current Promise state.\n\t */\n\tget state(): State {\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * Adds a callback to the promise to be invoked when the asynchronous operation completes successfully.\n\t */\n\tthen<U>(onFulfilled?: (value?: T) => (U | Thenable<U>), onRejected?: (reason?: Error) => (U | Thenable<U>)): Promise<U> {\n\t\treturn (<typeof Promise> this.constructor).copy(this.promise.then(onFulfilled, onRejected));\n\t}\n}\n\n/**\n * The State enum represents the possible states of a promise.\n */\nexport enum State {\n\tFulfilled,\n\tPending,\n\tRejected\n}\n\n/**\n * Thenable represents any object with a callable `then` property.\n */\nexport interface Thenable<T> {\n\tthen<U>(onFulfilled?: (value?: T) => U | Thenable<U>, onRejected?: (error?: any) => U | Thenable<U>): Thenable<U>;\n}\n"]}