{"version":3,"file":"aspect.js","sourceRoot":"","sources":["aspect.ts"],"names":["advise","getDispatcher","after","around","before","on"],"mappings":"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","sourcesContent":["import { Handle } from './interfaces';\nimport { createHandle } from './lang';\n\ninterface Advised {\n\tid?: number;\n\tadvice: Function;\n\tprevious?: Advised;\n\tnext?: Advised;\n\treceiveArguments?: boolean;\n}\n\ninterface Dispatcher {\n\t(): any;\n\ttarget: any;\n\tbefore?: Advised;\n\taround?: Advised;\n\tafter?: Advised;\n}\n\nlet nextId = 0;\n\nfunction advise(dispatcher: Dispatcher, type: string, advice: Function, receiveArguments?: boolean): Handle {\n\tlet previous = (<any> dispatcher)[type];\n\tlet advised: Advised = {\n\t\tid: nextId++,\n\t\tadvice: advice,\n\t\treceiveArguments: receiveArguments\n\t};\n\n\tif (previous) {\n\t\tif (type === 'after') {\n\t\t\t// add the listener to the end of the list\n\t\t\t// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t\t\twhile (previous.next && (previous = previous.next)) {}\n\t\t\tprevious.next = advised;\n\t\t\tadvised.previous = previous;\n\t\t}\n\t\telse {\n\t\t\t// add to the beginning\n\t\t\tdispatcher.before = advised;\n\t\t\tadvised.next = previous;\n\t\t\tprevious.previous = advised;\n\t\t}\n\t}\n\telse {\n\t\t(<any> dispatcher)[type] = advised;\n\t}\n\n\tadvice = previous = null;\n\n\treturn createHandle(function () {\n\t\tlet previous = advised.previous;\n\t\tlet next = advised.next;\n\n\t\tif (!previous && !next) {\n\t\t\t(<any> dispatcher)[type] = null;\n\t\t}\n\t\telse {\n\t\t\tif (previous) {\n\t\t\t\tprevious.next = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(<any> dispatcher)[type] = next;\n\t\t\t}\n\n\t\t\tif (next) {\n\t\t\t\tnext.previous = previous;\n\t\t\t}\n\t\t}\n\n\t\tdispatcher = advised.advice = advised = null;\n\t});\n}\n\nfunction getDispatcher(target: any, methodName: string): Dispatcher {\n\tconst existing = target[methodName];\n\tlet dispatcher: Dispatcher;\n\n\tif (!existing || existing.target !== target) {\n\t\t// no dispatcher\n\t\ttarget[methodName] = dispatcher = <Dispatcher> function (): any {\n\t\t\tlet executionId = nextId;\n\t\t\tlet args = arguments;\n\t\t\tlet results: any;\n\t\t\tlet before = dispatcher.before;\n\n\t\t\twhile (before) {\n\t\t\t\tif (before.advice) {\n\t\t\t\t\targs = before.advice.apply(this, args) || args;\n\t\t\t\t}\n\t\t\t\tbefore = before.next;\n\t\t\t}\n\n\t\t\tif (dispatcher.around) {\n\t\t\t\tresults = dispatcher.around.advice(this, args);\n\t\t\t}\n\n\t\t\tlet after = dispatcher.after;\n\t\t\twhile (after && after.id < executionId) {\n\t\t\t\tif (after.advice) {\n\t\t\t\t\tif (after.receiveArguments) {\n\t\t\t\t\t\tlet newResults = after.advice.apply(this, args);\n\t\t\t\t\t\tresults = newResults === undefined ? results : newResults;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults = after.advice.call(this, results, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tafter = after.next;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\n\t\tif (existing) {\n\t\t\tdispatcher.around = {\n\t\t\t\tadvice: function (target: any, args: any[]): any {\n\t\t\t\t\treturn existing.apply(target, args);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tdispatcher.target = target;\n\t}\n\telse {\n\t\tdispatcher = existing;\n\t}\n\n\ttarget = null;\n\n\treturn dispatcher;\n}\n\n/**\n * Attaches \"after\" advice to be executed after the original method.\n * The advising function will receive the original method's return value and arguments object.\n * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original method's return value and arguments object\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function after(target: any, methodName: string, advice: (originalReturn: any, originalArgs: IArguments) => any): Handle {\n\treturn advise(getDispatcher(target, methodName), 'after', advice);\n}\n\n/**\n * Attaches \"around\" advice around the original method.\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function around(target: any, methodName: string, advice: (previous: Function) => Function): Handle {\n\tlet dispatcher = getDispatcher(target, methodName);\n\tlet previous = dispatcher.around;\n\tlet advised = advice(function (): any {\n\t\treturn previous.advice(this, arguments);\n\t});\n\n\tdispatcher.around = {\n\t\tadvice: function (target: any, args: any[]): any {\n\t\t\treturn advised ?\n\t\t\t\tadvised.apply(target, args) :\n\t\t\t\tprevious.advice(target, args);\n\t\t}\n\t};\n\n\tadvice = null;\n\n\treturn createHandle(function () {\n\t\tadvised = dispatcher = null;\n\t});\n}\n\n/**\n * Attaches \"before\" advice to be executed before the original method.\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function before(target: any, methodName: string, advice: (...originalArgs: any[]) => any[] | void): Handle {\n\treturn advise(getDispatcher(target, methodName), 'before', advice);\n}\n\n/**\n * Attaches advice to be executed after the original method.\n * The advising function will receive the same arguments as the original method.\n * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original method\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function on(target: any, methodName: string, advice: (...originalArgs: any[]) => any): Handle {\n\treturn advise(getDispatcher(target, methodName), 'after', advice, true);\n}\n"]}