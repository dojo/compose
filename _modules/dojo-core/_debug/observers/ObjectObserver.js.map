{"version":3,"file":"ObjectObserver.js","sourceRoot":"","sources":["ObjectObserver.ts"],"names":["BaseObjectObserver","BaseObjectObserver.constructor","Es7Observer","Es7Observer.constructor","Es7Observer._setObserver","Es7Observer.destroy","Es7Observer.observeProperty","Es7Observer.removeProperty","getPropertyDescriptor","Es5Observer","Es5Observer.constructor","Es5Observer._dispatch","Es5Observer._restore","Es5Observer._schedule","Es5Observer.destroy","Es5Observer.observeProperty","Es5Observer.removeProperty"],"mappings":"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","sourcesContent":["import { add as hasAdd } from '../has';\nimport { Hash } from '../interfaces';\nimport { Observer, PropertyEvent } from './interfaces';\nimport { is as isIdentical } from '../object';\nimport { queueMicroTask } from '../queue';\nimport Scheduler from '../Scheduler';\n\nhasAdd('object-observe', typeof (<any> Object).observe === 'function');\n\ninterface Es7ChangeEvent {\n\tname: string;\n\tobject: {};\n\toldValue: any;\n\ttype: string;\n}\n\nexport class BaseObjectObserver {\n\tprotected _listener: (events: PropertyEvent[]) => any;\n\tprotected _propertyStore: {};\n\tprotected _target: any;\n\n\tconstructor(kwArgs?: KwArgs) {\n\t\tthis._listener = kwArgs.listener;\n\t\tthis._propertyStore = {};\n\t\tthis._target = kwArgs.target;\n\t}\n}\n\nexport interface KwArgs {\n\tlistener: (events: PropertyEvent[]) => any;\n\tnextTurn?: boolean;\n\tonlyReportObserved?: boolean;\n\ttarget: {};\n}\n\nexport class Es7Observer extends BaseObjectObserver implements Observer {\n\t/**\n\t * Determines whether to block notifications for properties not added via `observeProperty`.\n\t * Defaults to `true.`\n\t *\n\t * Since `Object.observe` automatically reports any changes to the underlying object, there\n\t * needs to be a mechanism for ensuring consistency with `ObjectObserver` in environments\n\t * without a native `Object.observe` implementation.\n\t */\n\tonlyReportObserved: boolean;\n\n\tprotected _observeHandler: (changes: any[]) => void;\n\n\t/**\n\t * Creates a new Es7Observer that uses `Object.observe` to watch and notify listeners of changes.\n\t *\n\t * Requires a native `Object.observe` implementation.\n\t *\n\t * @constructor\n\t *\n\t * @param kwArgs\n\t * The `kwArgs` object is expected to contain the target object to observe and the callback\n\t * that will be fired when changes occur.\n\t */\n\tconstructor(kwArgs: KwArgs) {\n\t\tsuper(kwArgs);\n\n\t\tthis.onlyReportObserved = ('onlyReportObserved' in kwArgs) ? kwArgs.onlyReportObserved : true;\n\t\tthis._setObserver();\n\t}\n\n\t/**\n\t * Initializes observation on the underlying object, preventing multiple changes to the same\n\t * property from emitting multiple notifications.\n\t */\n\tprotected _setObserver(): void {\n\t\tconst store = this._propertyStore;\n\t\tconst target = this._target;\n\n\t\tthis._observeHandler = function (changes: Es7ChangeEvent[]): void {\n\t\t\tconst propertyMap: Hash<number> = {};\n\t\t\tconst events: PropertyEvent[] = changes.reduce(function (\n\t\t\t\tevents: PropertyEvent[],\n\t\t\t\tchange: Es7ChangeEvent\n\t\t\t): PropertyEvent[] {\n\t\t\t\tconst property: string = change.name;\n\n\t\t\t\tif (!this.onlyReportObserved || (property in store)) {\n\t\t\t\t\tif (property in propertyMap) {\n\t\t\t\t\t\tevents.splice(propertyMap[property], 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyMap[property] = events.length;\n\n\t\t\t\t\tevents.push({\n\t\t\t\t\t\ttarget: target,\n\t\t\t\t\t\tname: property\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn events;\n\t\t\t}.bind(this), []);\n\n\t\t\tif (events.length) {\n\t\t\t\tthis._listener(events);\n\t\t\t}\n\t\t}.bind(this);\n\n\t\t(<any> Object).observe(target, this._observeHandler);\n\t}\n\n\t/**\n\t * Ends all notifications on the target.\n\t */\n\tdestroy(): void {\n\t\tconst target = this._target;\n\n\t\t(<any> Object).unobserve(target, this._observeHandler);\n\t\tthis._listener = this._observeHandler = this._propertyStore = this._target = null;\n\t}\n\n\t/**\n\t * Enables notifications for the given property (or properties).\n\t *\n\t * If the `onlyReportObserved` option is `false`, then adding new properties will have no effect until\n\t * `onlyReportObserved` is reset to `true`.\n\t *\n\t * @param properties The property name or arguments list of property names that will be observed.\n\t */\n\tobserveProperty(...properties: string[]): void {\n\t\tconst store = <any> this._propertyStore;\n\n\t\tproperties.forEach(function (property: string): void {\n\t\t\tstore[property] = 1;\n\t\t});\n\t}\n\n\t/**\n\t * Disables notifications for the given property (or properties).\n\t *\n\t * If the `onlyReportObserved` option is `false`, then removing properties will have no effect until\n\t * `onlyReportObserved` is reset to `true`.\n\t *\n\t * * @param properties The property name or arguments list of property names that will be removed.\n\t */\n\tremoveProperty(...properties: string[]): void {\n\t\tconst store = this._propertyStore;\n\n\t\tproperties.forEach(function (property: string): void {\n\t\t\t// Since the store is just a simple map, using the `delete` operator is not problematic.\n\t\t\tdelete (<any> store)[property];\n\t\t});\n\t}\n}\n\n/**\n * In environments with no native `Object.observe` implementation, the notification system involves\n * swapping out the underlying setters for observed properties with a setter that fires a registered\n * callback. In order to properly unobserve properties, it is necessary to retrieve the original property\n * descriptors, own or inherited. Since it is possible to observe properties that do not yet exist, a\n * default descriptor can be returned. This default descriptor is the same as that generated by simple\n * `object.property = value` operations.\n */\nfunction getPropertyDescriptor(target: {}, property: string): PropertyDescriptor {\n\tlet descriptor: PropertyDescriptor;\n\n\tif (!(property in target)) {\n\t\treturn {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t};\n\t}\n\n\tdo {\n\t\tdescriptor = Object.getOwnPropertyDescriptor(target, property);\n\t} while (!descriptor && (target = Object.getPrototypeOf(target)));\n\n\treturn descriptor;\n}\n\nexport class Es5Observer extends BaseObjectObserver implements Observer {\n\t/**\n\t * The scheduler used to mimic native `Object.observe` reporting. Note that all changes to all\n\t * observed objects are notified within the same scheduled microtask.\n\t */\n\tprotected static _scheduler: Scheduler;\n\n\t/**\n\t * Determines whether change notifications should be fired immediately (`false`) or queued with\n\t * the scheduler (`true`, thus mimicking native `Object.observe` behavior). Defaults to `true`.\n\t */\n\tnextTurn: boolean;\n\n\tprotected _boundDispatch: () => void;\n\tprotected _currentlyScheduled: Hash<PropertyEvent>;\n\tprotected _descriptors: Hash<PropertyDescriptor>;\n\tprotected _scheduler: Scheduler;\n\n\t/**\n\t * Creates a new Es5Observer to watch and notify listeners of changes.\n\t *\n\t * This should only be used when 1) there is no native `Object.observe` implementation or 2) notifications\n\t * should be fired immediately rather than queued.\n\t *\n\t * @constructor\n\t *\n\t * @param kwArgs\n\t * The `kwArgs` object is expected to contain the target object to observe and the callback\n\t * that will be fired when changes occur.\n\t */\n\tconstructor(kwArgs: KwArgs) {\n\t\tsuper(kwArgs);\n\n\t\tif (!(<any> this.constructor)._scheduler) {\n\t\t\t(<any> this.constructor)._scheduler = new Scheduler({ queueFunction: queueMicroTask });\n\t\t}\n\n\t\tthis.nextTurn = ('nextTurn' in kwArgs) ? kwArgs.nextTurn : true;\n\n\t\tthis._descriptors = {};\n\t\tthis._scheduler = (<any> this.constructor)._scheduler;\n\t\tthis._boundDispatch = this._dispatch.bind(this);\n\t}\n\n\tprotected _dispatch() {\n\t\tlet queue = this._currentlyScheduled;\n\t\tlet events: PropertyEvent[] = Object.keys(queue).map(function (property: string): PropertyEvent {\n\t\t\treturn queue[property];\n\t\t});\n\n\t\tthis._currentlyScheduled = null;\n\t\tthis._listener(events);\n\t}\n\n\tprotected _restore(property: string): void {\n\t\tlet target = this._target;\n\t\tlet store = this._propertyStore;\n\n\t\tObject.defineProperty(target, property, (this._descriptors[property] || {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: target[property],\n\t\t\twritable: true\n\t\t}));\n\n\t\ttarget[property] = (<any> store)[property];\n\t}\n\n\tprotected _schedule(property: string): void {\n\t\tlet event: PropertyEvent = {\n\t\t\ttarget: this._target,\n\t\t\tname: property\n\t\t};\n\n\t\tif (this.nextTurn) {\n\t\t\tif (!this._currentlyScheduled) {\n\t\t\t\tthis._currentlyScheduled = {};\n\t\t\t\tthis._scheduler.schedule(this._boundDispatch);\n\t\t\t}\n\n\t\t\tthis._currentlyScheduled[property] = event;\n\t\t}\n\t\telse {\n\t\t\tthis._listener([ event ]);\n\t\t}\n\t}\n\n\t/**\n\t * Ends all notifications on the target, restoring it to its original state.\n\t */\n\tdestroy(): void {\n\t\tlet descriptors = this._descriptors;\n\n\t\tObject.keys(descriptors).forEach(this._restore, this);\n\t\tthis._descriptors = this._listener = this._propertyStore = this._target = null;\n\t}\n\n\t/**\n\t * Enables notifications for the given property (or properties).\n\t *\n\t * @param properties The property name or arguments list of property names that will be observed.\n\t */\n\tobserveProperty(...properties: string[]): void {\n\t\tlet target = this._target;\n\t\tlet store = <any> this._propertyStore;\n\t\tlet self = this;\n\n\t\tproperties.forEach(function (property: string): void {\n\t\t\tlet descriptor: PropertyDescriptor = getPropertyDescriptor(target, property);\n\n\t\t\tif (descriptor.writable) {\n\t\t\t\tlet observableDescriptor: PropertyDescriptor = {\n\t\t\t\t\tconfigurable: descriptor ? descriptor.configurable : true,\n\t\t\t\t\tenumerable: descriptor ? descriptor.enumerable : true,\n\t\t\t\t\tget: function (): any {\n\t\t\t\t\t\treturn store[property];\n\t\t\t\t\t},\n\t\t\t\t\tset: function (value: any): void {\n\t\t\t\t\t\tlet previous: any = store[property];\n\n\t\t\t\t\t\tif (!isIdentical(value, previous)) {\n\t\t\t\t\t\t\tstore[property] = value;\n\n\t\t\t\t\t\t\tself._schedule(property);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tstore[property] = target[property];\n\t\t\t\tself._descriptors[property] = descriptor;\n\t\t\t\tObject.defineProperty(target, property, observableDescriptor);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Disables notifications for the given property (or properties).\n\t *\n\t * @param properties The property name or arguments list of property names that will be removed.\n\t */\n\tremoveProperty(...properties: string[]): void {\n\t\tlet store = this._propertyStore;\n\n\t\tproperties.forEach(function (property: string): void {\n\t\t\tthis._restore(property);\n\t\t\t// Since the store is just a simple map, using the `delete` operator is not problematic.\n\t\t\tdelete (<any> store)[property];\n\t\t}, this);\n\t}\n}\n"]}