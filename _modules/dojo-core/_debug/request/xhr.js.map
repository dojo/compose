{"version":3,"file":"xhr.js","sourceRoot":"","sources":["xhr.ts"],"names":["xhr","xhr.getHeader"],"mappings":"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","sourcesContent":["import Task from '../async/Task';\nimport RequestTimeoutError from './errors/RequestTimeoutError';\nimport global from '../global';\nimport has from '../has';\nimport { RequestOptions, Response, ResponsePromise } from '../request';\nimport { generateRequestUrl } from './util';\n\nexport interface XhrRequestOptions extends RequestOptions {\n\tblockMainThread?: boolean;\n}\n\n/**\n * A lookup table for valid `XMLHttpRequest#responseType` values.\n *\n * 'json' deliberately excluded since it is not supported in all environments, and as there is\n * already a filter for it in '../request'. Default '' and 'text' values also deliberately excluded.\n */\nconst responseTypeMap: { [key: string]: string; } = {\n\tarraybuffer: 'arraybuffer',\n\t// XHR2 environments that do not support `responseType=blob` still support `responseType=arraybuffer`,\n\t// which is a better way of handling blob data than as a string representation.\n\tblob: has('xhr2-blob') ? 'blob' : 'arraybuffer',\n\tdocument: 'document'\n};\n\nexport default function xhr<T>(url: string, options: XhrRequestOptions = {}): ResponsePromise<T> {\n\tconst request = new XMLHttpRequest();\n\tconst requestUrl = generateRequestUrl(url, options);\n\tconst response: Response<T> = {\n\t\tdata: null,\n\t\tnativeResponse: request,\n\t\trequestOptions: options,\n\t\tstatusCode: null,\n\t\tstatusText: null,\n\t\turl: requestUrl,\n\n\t\tgetHeader(name: string): string {\n\t\t\treturn request.getResponseHeader(name);\n\t\t}\n\t};\n\n\tconst promise = new Task<Response<T>>(function (resolve, reject): void {\n\t\tif (!options.method) {\n\t\t\toptions.method = 'GET';\n\t\t}\n\n\t\tif ((!options.user || !options.password) && options.auth) {\n\t\t\tlet auth = options.auth.split(':');\n\t\t\toptions.user = decodeURIComponent(auth[0]);\n\t\t\toptions.password = decodeURIComponent(auth[1]);\n\t\t}\n\n\t\trequest.open(options.method, requestUrl, !options.blockMainThread, options.user, options.password);\n\n\t\tif (has('xhr2') && options.responseType in responseTypeMap) {\n\t\t\trequest.responseType = responseTypeMap[options.responseType];\n\t\t}\n\n\t\trequest.onreadystatechange = function (): void {\n\t\t\tif (request.readyState === 4) {\n\t\t\t\trequest.onreadystatechange = function () {};\n\n\t\t\t\tif (options.responseType === 'xml') {\n\t\t\t\t\tresponse.data = request.responseXML;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresponse.data = ('response' in request) ? request.response : request.responseText;\n\t\t\t\t}\n\n\t\t\t\tresponse.statusCode = request.status;\n\t\t\t\tresponse.statusText = request.statusText;\n\t\t\t\tif (response.statusCode >= 200 && response.statusCode < 400) {\n\t\t\t\t\tresolve(response);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treject(response.statusText ?\n\t\t\t\t\t\tnew Error(response.statusText) :\n\t\t\t\t\t\tnew Error('An error prevented completion of the request.')\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (options.timeout > 0 && options.timeout !== Infinity) {\n\t\t\trequest.timeout = options.timeout;\n\t\t\trequest.ontimeout = function () {\n\t\t\t\treject(new RequestTimeoutError('The XMLHttpRequest request timed out.'));\n\t\t\t};\n\t\t}\n\n\t\tconst headers = options.headers;\n\t\tlet hasContentTypeHeader: boolean = false;\n\t\tfor (let header in headers) {\n\t\t\tif (header.toLowerCase() === 'content-type') {\n\t\t\t\thasContentTypeHeader = true;\n\t\t\t}\n\n\t\t\trequest.setRequestHeader(header, headers[header]);\n\t\t}\n\n\t\tif (!headers || !('X-Requested-With' in headers)) {\n\t\t\trequest.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\t\t}\n\n\t\tif (!hasContentTypeHeader && has('formdata') && options.data instanceof global.FormData) {\n\t\t\t// Assume that most forms do not contain large binary files. If that is not the case,\n\t\t\t// then \"multipart/form-data\" should be manually specified as the \"Content-Type\" header.\n\t\t\trequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\t\t}\n\n\t\tif (options.responseType === 'xml' && request.overrideMimeType) {\n\t\t\t// This forces the XHR to parse the response as XML regardless of the MIME-type returned by the server\n\t\t\trequest.overrideMimeType('text/xml');\n\t\t}\n\n\t\trequest.send(options.data);\n\t}, function () {\n\t\trequest && request.abort();\n\t});\n\n\treturn promise;\n}\n"]}