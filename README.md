# dojo-compose

[![Build Status](https://travis-ci.org/dojo/compose.svg?branch=master)](https://travis-ci.org/dojo/compose)
[![codecov.io](http://codecov.io/github/dojo/compose/coverage.svg?branch=master)](http://codecov.io/github/dojo/compose?branch=master)

A composition library.

**NOTE** At this stage, this is a functional prototype [for a proposal](https://docs.google.com/document/d/10i5agK1Ot1eiB_R5JVEVHY41B0rEvjVyeQ1rl50DTdY/edit#heading=h.mknz10lo6jxp) that is under discussion.  This is not yet intended for production use.  Consider it *pre-alpha* and is intended to allow people to assess the API. **Use at your own risk and the final API may or may not look anything like this**

This library embraces the concepts of "composition" versus classical Object Oriented inheritance.  The classical model follows a pattern whereby you add functionality to an ancestor by extending it.  Subsequently all other descendants from that class will also inherit that functionality.

In a composition model, the preferred pattern is to create logical feature classes which are then composited together to create a resulting class.  It is believed that this pattern increases code reuse, focuses on the engineering of self contained "features" with minimal cross dependency.

Also, all the classes generated by the library are "immutable".  Any extension of the class will result in a new class constructor and prototype.  This is in order to minimize the amount of unanticipated consequences of extension for anyone who is referencing a previous class.

## Features

The examples below are provided in TypeScript syntax.  The package does work under JavaScript, but for clarity, the examples will only include one syntax.  See below for how to utilize the package under JavaScript.

### Class Creation

The library supports creating a "base" class from ES6 Classes, JavaScript constructor functions, or an object literal prototype.  In addition an initialization function can be provided.

#### Creation

The `compose` module's default export is a function which creates classes.  This is also available as `.create()` which is decorated onto the `compose` function.

If you want to create a new class via a prototype and create an instance of it, you would want to do something like this:

```typescript
import compose from 'dojo-compose/compose';

const Foo = compose({
	foo: function () {
		console.log('foo');
	},
	bar: 'bar',
	qat: 1
});

const foo = new Foo();
```

If you want to create a new class via an ES6/TypeScript class and create an instance of it, you would want to do something like this:

```typescript
import compose from 'dojo-compose/compose';

class Foo {
	foo() {
		console.log('foo');
	};
	bar: string = 'bar';
	qat: number = 1;
}

const ComposeFoo = compose(Foo);

const foo = new ComposeFoo();
```

You can also subclass:

```typescript
import compose from 'dojo-compose/compose';

const Foo = compose({
	foo: function () {
		console.log('foo');
	},
	bar: 'bar',
	qat: 1
});

const MyFoo = compose(Foo);

const foo = new MyFoo();
```

#### Creation with Initializer

During creation, `compose` takes a second optional argument, which is an initializer function.  The constructor pattern for all `compose` classes is to take an optional `options` argument.  Therefore the initialization function should take this optional argument:

```typescript
import compose from 'dojo-compose/compose';

interface FooOptions {
	foo?: Function,
	bar?: string,
	qat?: number
}

function fooInit(options?: FooOptions) {
	if (options) {
		for (let key in options) {
			this[key] = options[key]
		}
	}
}

const Foo = compose({
	foo: function () {
		console.log('foo');
	},
	bar: 'bar',
	qat: 1
}, fooInit);

const foo1 = new Foo();
const foo2 = new Foo({
	bar: 'baz'
});
```

### Class Extension

The `compose` module's default export also has a property, `extend`, which allows the enumerable, own properties of a literal object to be added to the prototype of a class. The type of the resulting class will be inferred and include all properties of the extending object. It can be used to extend an existing compose class like this:

```typescript
import * as compose from 'dojo/compose';

let Foo = compose.create({
    foo: 'bar'
});

Foo = compose.extend(Foo, {
    bar: 1
});

let foo = new Foo();

foo.foo = 'baz';
foo.bar = 2;
```

Or using chaining:

```typescript
import * as compose from 'dojo/compose';

const Foo = compose.create({
    foo: 'bar'
}).extend({
    bar: 1
});

let foo = new Foo();

foo.foo = 'baz';
foo.bar = 2;
```

#### Implementing an interface

`extend` can also be used to implement an interface:

```typescript
import * as compose from 'dojo/compose';

interface Bar {
    bar?: number;
}

const Foo = compose.create({
    foo: 'bar'
}).extend<Bar>({});
```

Or

```typescript
const Foo = compose.create({
    foo: 'bar'
}).extend(<Bar> {});
```

### Mixing in Traits/State

Oftentimes the need arises to take an existing class and add not just properties, but also behavior, or traits. The `compose` module's default export has a `mixin` property that provides this functionality. It can be used to mix in another compose class:

```typescript
import * as compose from 'dojo/compose';

const Foo = compose.create({
    foo: 'bar'
});

const Bar = compose.create({
    bar: function () {
        console.log('bar');
    }
});

const FooBar = compose.mixin(Foo, Bar);

const fooBar = new FooBar();

fooBar.bar(); // logs "bar"
``` 

Or to mix in an ES6 class:

```typescript
import * as compose from 'dojo/compose';

const Foo = compose.create({
    foo: 'bar'
});

class Bar {
    bar() { console.log('bar'); }
}

const FooBar = compose.mixin(Foo, Bar);

const fooBar = new FooBar();

fooBar.bar(); // logs "bar"
```
Note that when mixing in an ES6 class only methods will be mixed into the resulting class, not state.

### Using Generics

`compose` utilizes TypeScript generics and type inference to type the resulting classes.  Most of the time, this will work without any need to declare your types.  There are situations though where you may want to be more explicit about your interfaces and `compose` can accommodate that by passing in generics when using the API. Here is an example of creating a class that requires generics using `compose`:

```typescript
class Foo<T> {
    foo: T;
}

class Bar<T> {
    bar(opt: T): void {
        console.log(opt);
    }
}

interface FooBarClass {
	new <T, U>(): Foo<T>&Bar<U>;
}

let FooBar: FooBarClass = compose(Foo).mixin(<any>  Bar);

let fooBar = new FooBar<number, any>();
```

### Overlaying Functionality

If you want to make modifications to the prototype of a class that are difficult to perform with simple mixins or extensions, you can use the `overlay` function provided on the default export of the `compose` module. `overlay` takes one argument, a function which will be passed a copy of the prototype of the existing class, and returns a new class whose type reflects the modifications made to the existing prototype: 

```typescript
import * as compose from 'dojo/compose';

const Foo = compose.create({
    foo: 'bar'
});

const MyFoo = Foo.overlay(function (proto) {
    proto.foo = 'qat';
});

const myFoo = new MyFoo();
console.log(myFoo.foo); // logs "qat"
```
Note that as with all the functionality provided by `compose`, the existing class is not modified.

## How do I use this package?

For now, until the package is fully published you will need to clone the repository to your local machine:

```bash
$ git clone https://github.com/dojo/compose.git
```

Then you will need to navigate to the root of the repository and do an `npm` install:

```bash
$ npm install
```

If you don't have Grunt command line installed globally, you will need to also:

```bash
$ npm install grunt-cli -g
```

In order to get a build of the code which you can then use for runtime, you will need to:

```bash
$ grunt dist
```

Which will output UMD modules and a `d.ts` file for the library to `dist`.  This library also is dependent run-time on `dojo-core` and includes a compiled version in `_modules`.

## How do I contribute?

We appreciate your interest!  Please see the [Guidelines Repository](https://github.com/dojo/guidelines#readme) for the Contributing Guidelines and Style Guide.

## Testing

Test cases MUST be written using [Intern](https://theintern.github.io) using the Object test interface and Assert assertion interface.

90% branch coverage MUST be provided for all code submitted to this repository, as reported by Istanbul’s combined coverage results for all supported platforms.

© 2015 Dojo Foundation & contributors. [New BSD](http://opensource.org/licenses/BSD-3-Clause) license.
